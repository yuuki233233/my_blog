# 题目
![](图片/移动零.png)
# 解题思路
## 整体框架
### 解法1（利用辅助数组）
因为题目限制，无法使用辅助数组
![](图片/移动零解法1.png)
```
创建一个辅助数组，遍历原数组如果非零则头插，零则尾插
```
### 解法2（）
![](图片/移动零解法2.png)
```
// 左边非零，右边零
最终数组:[0, cur] [cur+1, n];

原始数组:[0, cur] [cur+1, i-1] [i, n-1];

想法：严格控制cur的边界，左为非零，右为零
1. 当i为非零，i与cur+1换位置，cur++将非零纳入左数组，然后i++寻找右数组的新数据
2. 当i为零，i++将零纳入中间数组
```
# 代码演示
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        for(int cur = -1, i = 0;  i < nums.size(); i++)
        {
            if(nums[i])
            {
                swap(nums[cur + 1], nums[i]);
                cur++;
            }
        }
    }
};
```