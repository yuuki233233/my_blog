# strlen函数的模拟实现
---
## 1>使用计数器

思路：通过指针指向数组首地址，向右找到字符串末尾的\0,每走一次计数器＋1

实现：
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<assert.h>//断言头文件

size_t my_strlen(const char* arr)
{
	assert(arr);//断言，若不是数组就报错
	int count = 0;//计数器
	while (*arr != '\0')
	{
		count++;
		arr++;
	}
	return count;
}

int main()
{
	char arr[] = "abcdef";
	size_t len = my_strlen(arr);
	printf("%zd\n", len);//打印出len=6

	return 0;
}

```

## 2>双指针

思路：先设定一个首元素地址，再利用末元素地址，然后相减
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<assert.h>//断言头文件

size_t my_strlen(const char* arr)
{
	assert(arr);//如果不是数组，就报错
	char* p = arr;//首元素
	char* ps = arr;//设个首元素，往下找到\0的地址
	while (*ps != '\0')
	{
		ps++;
	}
	return ps - p;//相减，得到中间元素
}

int main()
{
	char arr[] = "hallo world";
	size_t len = my_strlen(arr);
	printf("%zu\n", len);
	return 0;
}
```

## 3>递归函数

思路：由复杂到简单的思想
```
 把hallo world拆成1 + allo world
 继续拆成1 + 1 + llo world。一直循环到只有\0停下
```

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

size_t my_strlen(const char* arr)
{
	if (*arr != '\0')
	{
		return 1 + my_strlen(arr + 1);//当不为\0时，让数组地址往下一个加个整形，回到函数
	}
	else
		return 0;
}

int main()
{
	char arr[] = "hallo world";
	size_t len = my_strlen(arr);
	printf("%zu\n", len);
	return 0;
}
```

# strcpy函数的模拟实现
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<assert.h>

void my_strcpy(char* arr1, char* arr2)
{
	assert(arr1 != NULL);
	assert(arr2 != NULL);
	//拷贝'\0'之前的字符
	while (*arr1 != '\0')
	{
		*arr2 = *arr1;
		arr2++;//可改成*arr2++ = *arr1++;
		arr1++;
	}
	//拷贝'\0'字符
	*arr2 = *arr1;
}

int main()
{
	char arr1[] = "hallo world";
	char arr2[20] = { 0 };

	my_strcpy(arr1, arr2);

	printf("%s\n", arr2);
	return 0;
}
```

# strcmp函数的模拟实现
## 代码分析图示：
---

![](图片/QQ20251003-200437%201.png)

## 模拟实现
---

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<assert.h>断言头文件

int my_strcmp(char* arr1, char* arr2)
{
	assert(arr1 && arr2);//判断是否为空指针
	while (*arr1 == *arr2)
	{
		if (*arr1 == '\0')//当最后都相等时，返回0
			return 0;
		arr1++;//如上面图所示
		arr2++;
	}

	if (*arr1 > *arr2)//当大于时，返回1
		return 1;
	if (*arr1 < *arr2)//当小于时，返回-1
		return -1;
}

int main()
{
	char arr1[] = "hallo";
	char arr2[] = "hallo";//两字符串相等，应返回0
	int set = my_strcmp(arr1, arr2);
	printf("%d\n", set);//set = 0
	return 0;
}
```

# strcat函数的模拟实现
## 代码分析图示：
---
![](图片/屏幕截图%202025-10-02%20223551%201.png)

## 代码实现：
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<assert.h>

//返回值为char*，接收类型也为char*
char* my_strcat(char* dest, const char* src)//const保护源数据，防止被修改
{
	//断言，若不是字符指针，则报错
	assert(dest && src);
	//保存dest首地址
	char* ret = dest;
	//1.找目标空间\0
	while (*dest != '\0')
		dest++;
	//2.拷贝到dest\0的后面，打印为halloworld\0
	while (*dest++ = *src++)
		;//空语句
	return ret;//函数的返回值为数组首元素，这样数组才能往下打印完全
}
int main()
{
	char arr1[20] = "hallo ";//追加空间要足够大
	char arr2[] = "world";

	char* s = my_strcat(arr1, arr2);//接收类型为char*
	printf("%s\n", arr1);
	printf("%s\n", s);
	printf("%s\n", my_strcat(arr1, arr2));//arr1已经为hallo world再与arr2进行合并，变为hallo worldworld

	return 0;
}
```
上面不同字符串追加成功了，那能不能追加自己

# strstr函数的模拟实现
---
## 代码分析图示：
![](图片/QQ20251004-135043%201.png)

## 代码实现：
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>//strstr头文件

char* my_strstr(char* str1, char* str2)
{
	const char* s1 = NULL;
	const char* s2 = NULL;//将s1与s2设为空指针
	const char* cur = str1;//设个cur指针指向首地址，方便回到上次查找str1的地方

	if (*str2 == '\0')//极端情况，str2没有字符
	{
		return (char*)str1;//则直接返回str1的首地址
	}

	while (*cur)//当*cur为'\0'退出循环,'\0'的ASCLL码值为0
	{
		s1 = cur;
		s2 = str2;//把s1、s2附上首元素地址

		while (*s1 != '\0' && *s2 != '0' && *s1 == *s2)
		{
			s1++;
			s2++;//查找两元素是否相同
			return (char*)cur;//查找到最后都相同时，返回
		}
		cur++;//条件不成立时，使cur向--→移一位，继续找一遍
	}
	return NULL;//条件不成立，返回空指针

}

int main()
{
	char arr1[] = "abcdefabcdef";
	char arr2[] = "cdef";
	char* ret = my_strstr(arr1, arr2);//传入实参
	if (ret == NULL)
		printf("没找到\n");
	else
		printf("%s\n", ret);
	return 0;
}
```

