# 1、进制的转换
---
计算机中，常用进制可分为：
- 二进制
- 八进制
- 十进制
- 十六进制

转化技巧：
- 二进制可以简单的转为八进制, 十进制, 十六进制
- 十进制可简单转化为二进制
- 要把十进制转化为八进制和十六进制时，可以先转为二进制，再转八进制或十六进制，反过来也一样
## 1.1 二进制转为八进制
---

| 二进制  | 1、 1        | 0、 1、1            |
| ---- | ----------- | ----------------- |
| 2的次方 | 2、1         | 4、2、1             |
| 计算   | (2×1)+(1×1) | (4×0)+(2×1)+(1×1) |
| 和    | 3           | 3                 |
| 八进制  | 3           | 3                 |

## 1.2 十进制转为二进制
---

| 十进制 | 16  |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 除2  | 16  | 8   | 4   | 2   | 1   |
| 余数  | 1   | 1   | 0   | 1   | 1   |
| 二进制 | 1   | 1   | 0   | 1   | 1   |

## 1.3 二进制转为十六进制
---

| 二进制  | 0、1、1、1                 | 1、0、1、1                 |
| ---- | ----------------------- | ----------------------- |
| 2的次方 | 8、4、2、1                 | 8、4、2、1                 |
| 计算   | (8×0)+(4×1)+(2×1)+(1×1) | (8×1)+(4×0)+(2×1)+(1×1) |
| 和    | 7                       | 11=B                    |
| 十六进制 | 7                       | B                       |

与八进制类似, 每**四个二进制相加**

## 1.4 十进制转化换
通常会把进制转为二进制，然后转为其他进制

# 2、原码, 反码, 补码
---

## 2.1 原码

为**整数的二进制**形式

## 2.2 反码

1. 正数：反码=原码
2. 负数：符号位不变，其余位按位取反

## 2.3 补码

1. 正数：补码=原码
2. 负数：补码=反码+1

## 2.4 示例
---

### 例 1：+18
+18 的绝对值二进制：18 = 16 + 2 → 00010010

· 原码：00010010
· 反码：00010010
· 补码：00010010

---

### 例 2：-18
+18 原码：00010010
-18 原码：10010010
-18 反码：11101101
-18 补码：11101110

---

### 例 3：+85
85 = 64 + 16 + 4 + 1 → 01010101

· 原码：01010101
· 反码：01010101
· 补码：01010101

---

### 例 4：-85
-85 原码：11010101
-85 反码：10101010
-85 补码：10101011

---

### 例 5：+0

· 原码：00000000
· 反码：00000000
· 补码：00000000

---

### 例 6：-0（原码和反码中有，补码中与 +0 相同）

· 原码：10000000
· 反码：11111111
· 补码：00000000

---

### 例 7：-1
-1 原码：10000001
-1 反码：11111110
-1 补码：11111111

---

### 例 8：-127（8 位原码最小整数）
-127 原码：11111111
-127 反码：10000000
-127 补码：10000001

---

### 例 9：-128（8 位补码最小整数）
-128 原码：无（8 位原码无法表示）
-128 反码：无
-128 补码：10000000

## 2.5 示例表格
---

| 十进制  | 原码       | 反码       | 补码       |
| ---- | -------- | -------- | -------- |
| +18  | 00010010 | 00010010 | 00010010 |
| -18  | 10010010 | 11101101 | 11101110 |
| +85  | 01010101 | 01010101 | 01010101 |
| -85  | 11010101 | 10101010 | 10101011 |
| +0   | 00000000 | 00000000 | 00000000 |
| -0   | 10000000 | 11111111 | 00000000 |
| -127 | 11111111 | 10000000 | 10000001 |
| +128 | 无        | 无        | 10000000 |



# 3、移动运算符
---
- 左移操作符int b = ( a << 1_)具有乘2的效果[ 左移1位, 右补1位0 ]❗注意一定是整数
```C
int a = 6;
int b = (a << 1);
printf("%d\n", b);//b = 12
```
- 右移操作符( 常见的是算术右移 )
- 如果是负数,具有除2效果,[右移一位,前面补1 ]; ❗不要移负数位,这是未定义
```C
int a = 6;
int b = (a >> 1);
printf("%d\n", b);//b = 3
```

# 4、位操作符
---
## 4.1 位操作符&(按位与), |(按位或), ^(按位异或), ~(按位取反)
---
我们需要先了解**位运算中的异或（`^`）操作**的两个关键性质：

- 性质 1：**一个数和它本身异或，结果为 0**，即 `a ^ a = 0`。
- 性质 2：**一个数和 0 异或，结果为它本身**，即 `a ^ 0 = a`。
- 按位与( a & b ),取两个整数的补数相加,有零取零,无零取1
- 按位或 只要有1则为1,无1则为零
- 按位异或 相同为零,相异为1
- 按位取反 对单个整数进行取反❗**必须都是整数**

## 4.2 变量交换
---

### 1>创建临时变量
---
```C
int a = 3;
int b = 5;
int c = 0;//创建变量c

c = a;
a = b;
b = c;
```

### 2>利用按位异或变量交换
---
```C
int a = 3;
int b = 5;

a = a ^ b;//a ^ a = 0
b = a ^ b;//b = a ^ b ^ b
a = a ^ b;//a = a ^ a ^ b
```
一般情况下都用**第一种**情况**因为可读性高**

## 4.3 计算二进制中一的个数
---
### 1>利用&1来计算二进制个数
---
例如：

| 13的二进制                              | 1的二进制                               |
| ----------------------------------- | ----------------------------------- |
| 00000000 00000000 00000000 00001101 | 00000000 00000000 00000000 00000001 |

 **把最后的数用&来求出1的个数, 然后再把13的二进制向右移一位
 
 代码如下
 ```C
 int n = 0;
scanf("%d", &n);
int count = 0;
int i = 0;
for (i = 0; i < 32; i++)
{
	if (((n >> i) & 1) == 1)
	{
		count++;
	}
}
printf("%d\n", count);
 ```
 因为整形int为32bit,需要0<i<32

### 2>利用n&(n-1)计算二进制1的个数
---

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int n = 0;
	scanf("%d", & n);
	int count = 0;
	while (n)
	{
		n = n & (n - 1);
		count++;
	}
	printf("%d\n", count);

	return 0;
}
```
**通过以下方式实现**


| n = 15     | 1111 |
| ---------- | ---- |
| n - 1 = 14 | 1110 |
| n          | 1110 |
|            |      |
| n - 1      | 1101 |
| n          | 1100 |
|            |      |
| n - 1      | 1011 |
| n          | 1000 |
|            |      |
| n-1        | 0111 |
| n          | 0000 |


## 4.4 利用按位或|来二进制置0或置1
---

实列:
```
//13的二进制序列:      00000000 00000000 00000000 00001101
//将1的二进制移动4位 : 00000000 00000000 00000000 00010000
// 按位或|
//将二进制序列改为 :   00000000 00000000 00000000 00011101
//将1二进制移动4位取~: 11111111 11111111 11111111 11101111
//按位与&
```
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int a = 13;
	int b = 1 << 4;
	a = a | b;
	printf("%d\n", a);

	b = ~b;
	a = a & b;
	printf("%d\n", a);

	return 0;
}
```

# 5、单目操作符
---
```
!, ++, --, &, *, +, -, ~, sizeof(类型)
```

- !表示否定
- ++分为前置和后置
- --分为前置和后置
- +为加号
- -为减号
- sizeof(数据类型)可算空间大小
- ~按位取反

# 6、逗号表达式
---

概念: 由逗号隔开的多个表达式,从**左向右依次执行**,**整个表达式的结果是最后一个表达式的结果**
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int a = 1;
	int b = 2;
	int c = (a = b + 10, a, b = a + 1);

	printf("%d\n", c);//c = 13

	return 0;
}
```

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
    a = get_val();
    count_val(a);
    while(a > 0)
    {
         a = get_val();
         count_val(a);
    }
	return 0;
}```
可简化为逗号表达式
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
    a = get_val();
    count_val(a);
    while(a = get_val(), count_val(a), a > 0)
    {
        
    }
	return 0;
}```

# 7、下表访问[], 函数调用()
---
## 7.1 下表引用操作符
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
    int arr[10] = {3, 4, 7, 8, 9, 10, 48};
    printf("%d\n",arr[3]);//打印8
    return 0;
}
```

## 7.2 函数调用操作符
---
**接受一个或者多个操作符**: 第一个操作数是传递给**函数的参数**
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int Add(int x, int y)
{
    return x + y;
}

void main()
{
    printf("hehe\n");
}

int main()
{
    printf("hehe\n");
    int ret = (2, 3);//函数
    test();//操作符
    return 0;
}
```


# 8、结构成员访问操作符
---
## 8.1 结构体与操作符
---
示例:
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

struct Student
{
    char name[20];
    int age;
    int high;
    float weight;
    int id[16];
}s4, s5, s6;
//s4, s5, s6是结构体全局变量

int main()
{
    struct Student s1 = { "张三", 20, 180, 75.5f, 1234567890 };//初始化
    struct Student s2 = { .age = 30, .name = "李四", .weight = 80.5f, .high = 177,  .id = 1234567891 };//不按顺序排的,前面要加.
    printf("%s %d %d %.1f %d\n", s1.name, s1.age, s1.high, s1.weight, s1.id);
        //struck Student s3;
        //s1, s2, s3是结构体的局部变量
        return 0;
}
```

# 9、整形提升
---

在表达式中各种长度可能小于int的整形, 都要有整型提升,如:char和short
1. 有符号整数提升是按照变量的数据类型的符号位来提升的
2. 无符号整数提升, 高位补0
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	char a = 127;
	//00000000 00000000 00000000 01111111
	//0111111 -a
	char b = 3;
	//00000000 00000000 00000000 00000011
	//00000011 -b
	char c = a + b;
	//00000000 00000000 00000000 01111111
	//00000000 00000000 00000000 00000011
	//00000000 00000000 00000000 10000010
	//10000010
	//
	//%d - 以十进制的形式打印有符号的整数
	//11111111 11111111 11111111 10000010补码
	//10000000 00000000 00000000 01111101反码
	//10000000 00000000 00000000 01111110原码
	printf("%d\n", c);
	return 0;
}
```


# 10、算术转换
---

若两个变量不同的类型相加或相减, 要转换类型
```C
int a = 5;
double b = 3.23
```

#  11、运算符的优先级
---

## 11.1 错误代码
```c
c + --c;
```

```C
a*b + b*c + c*d;
```




























