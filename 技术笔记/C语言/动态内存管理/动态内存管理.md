- 不管是C/C++中都会大量使用
- 使用C/C++实现数据结构时也会使用动态内存管理
# 1、为什么要有动态内存管理
---
## 原始的两种分配内存方式
---
1. 申请一个空间： ```int n = 10 //4个字节```，```char c = 'w' //1个字节```这个内容在[[指针总和]]中讲过
2. 分配连续空间：```char arr[20]; //20个字节```，```int arr2[20]; //80个字节```
- 一旦申请内存就无法调整
- 数组在申明时，必须指定数组的长度，数组空间一旦确定了大小，则不能调整

列如：描述班级学生的成绩
```C
int math[30];//大小固定
```
- 若只有26位同学，浪费了16个字节
- 若有35位同学，则不够空间
这时候如果程序员可以自己申请空间，那就方便管理内存
# 2、malloc和free
---
## 2.1malloc
C语言提供了一个动态内存开辟的函数：
```C
//头文件
#include<stdlib.h>
void* malloc(size_t size);
//申请4个int类型
//列如：int* p = (int*)malloc(4 * sizeof(int));
```
- 申请内存，由于不知道存什么，所有返回```void*```类型
- ```size_t size```是字节，常用```申请的类型个数 * sizeof(类型)```来写，清晰明了

注意：这个函数向内存申请一块**连续可用**的空间，并返回指向这块空间的指针。
- 如果开辟成功，则返回一个指向开辟好空间的指针。
- 如果开辟失败，则返回一个```NULL```
- 返回值的类型是```void*```,所有malloc喊上我并不知道开辟空间的类型，具体在使用的时候自己来决定。
- 如果参数```size```为0，malloc的行为标准是未定义的，取决于编译器。
## 2.2free
C语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的：
```C
//头文件
#include<stdlib.h>
void free (void* ptr);
//列如：free(p);
```
- 如果参数ptr指向的空间不是动态开辟的内存，那么free函数的行为是未定义的。
- 如果参数ptr是NULL指针，则函数什么事都不做。
## 2.3列子
---
```C
#include <stdio.h>
#include <stdlib.h>

int main()
{
	//申请5个int类型
	int* p = (int*)malloc(5 * sizeof(int));
	//判断是否为空指针
	if(p == NULL)
	{
		perror("malloc");
		return 1;
	}
	
	//使用申请的空间
	for(int i = 0; i < 5; i++)
	{
		*(p + i) = i + 1;
	}
	
	//打印
	for(int i = 0; i < 5; i++)
	{
		printf("%d ",*(p + i));
	}
	
	//释放空间
	free(p);
	
	//释放完变成野指针
	p = NULL;
	
	return 0;
}
```
- 申请了空间要判断是否为空指针
- 使用完一定要释放内存
# 3、calloc和realloc
---
## 3.1calloc函数
C语言还提供了一个函数叫calloc，calloc函数也用来动态内存分配：
```C
void* calloc (size_t num, size_t size);
//向内存申请5个int类型
//列如：int* p = (int*)calloc(5, sizeof(int));
```
- calloc返回地址，初始化为0，但malloc函数不会
- malloc函数会比calloc函数快些，因为calloc函数要初始化
- 剩下的使用都是一样的
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include <stdlib.h>

int main()
{
	//申请内存
	int* p = (int*)calloc(10, sizeof(int));
	//判断是否为空指针
	if (NULL != p)
	{
		int i = 0;
		//打印
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}
	//释放内存
	free(p);
	//p为野指针，让p指向空指针
	p = NULL;

	return 0;
}
```
打印的结果：
```
0 0 0 0 0 0 0 0 0 0
```
所以如果我们对申请的内存空间的内容要求初始化，那么可以很方便的使用calloc函数来完成任务
## 3.2realloc函数
---
- realloc函数的出现让动态内存管理更加灵活
- 有时候申请空间过小/过大，用realloc可以调整大小
语法形式如下：
```C
void* realloc (void* ptr, size_t size)
//列如：int* p = (int*)malloc(5 * sizeof(int));
//int* ptr = (int*)realloc(p, 40);
```
## 3.3示例
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

int main()
{
	//申请内存
	int* p = (int*)malloc(5 * sizeof(int));
	//赋值
	for (int i = 0; i < 5; i++)
	{
		*(p + i) = i + 1;
	}

	//修改内存大小
	int* ptr = (int*)realloc(p, 40);
	//错误写法：
	//p = (int*)realloc(p,40);
	//怕返回空指针，丢失旧数据

	//判断是否为空指针
	if (ptr != NULL)
	{
		//若不是把ptr的地址赋值给p
		p = ptr;
		//输入数据
		for (int i = 5; i < 10; i++)
		{
			*(p + i) = i + 1;
		}
		//打印数据
		for (int i = 0; i < 10; i++)
		{
			printf("%d ", p[i]);
		}
		//使用完释放空间
		free(p);
		//释放完p变为野指针，让p指向空指针
		p = NULL;
	}
	//若为空指针，则报错
	else
	{
		perror("realloc");
		return 1;
	}
	return 0;
}
```
## 3.4内存图
---
![](图片/QQ20251016-213932.png)
# 4、常见错误写法
---
## 4.1对NULL指针的解引用操作
```C
void test()
{
	int *p = (int*)malloc(INT_MAX / 4);
	*p = 20;//如果p的值是NULL，就会有问题
	free(p);
}
```
## 4.2对动态开辟空间的越界访问
```C
void test()
{
	int i = 0;
	int *p = (int*)malloc(10 * sizeof(int));
	if(NULL == p)
	{
		exit(EXIT_FAILURE);
	}
	for(i = 0; i <= 10; i++)
	{
		*(p+i) = i;//当i是10的时候越界访问
	}
	free(p);
}
```
## 4.3对非动态开辟内存使用free释放
```C
void test()
{
	int a = 10;//非手动申请内存
	int *p = &a;
	free(p);
}
```
## 4.4使用free释放一块动态开辟内存的一部分
```C
void test()
{
	int *p = (int *)malloc(100);
	p++;
	free(p);//p不再指向动态内存的起始位置
}
```
## 4.5对同一块动态内存多次释放
```C
void test()
{
	int *p = (int *)malloc(100);
	free(p);
	free(p);//重复释放
}
```
## 4.6动态开辟内存忘记释放（内存泄漏）
```C
void test()
{
	int *p = (int *)malloc(100);
	if(NULL != p)
	{
		*p = 20;
	}
}

int main()
{
	test();
	while(1);
}
```
- malloc函数/calloc函数/realloc函数申请的内存，如果不想使用，可以用free释放
- 如果没使用free释放，当程序运行结束时候，也会由操作系统回收的！

尽量做到
1. **忘记释放不再使用的动态开辟的空间会造成内存泄漏**
2. 切记：动态内存开辟的空间一定要释放，并且正确释放
3. 谁申请的空间谁释放
4. 如果不能释放，要告诉使用的人(地址或文档)，记得释放
# 5、动态内存经典笔试题分析
---
## 习题1
---
### 错误代码1
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

void GetMemory(char* p)
{
	//形参是实参的临时拷贝
	p = (char*)malloc(100);
	//p不会影响str
}
void Test(void)
{
	char* str = NULL;
	GetMemory(str);
	//p指向申请空间，当p离开函数时，p的生命周期结束(地址释放)
	//str原本指向p，但地址已经释放
	strcpy(str, "hello world");
	printf(str);
}
```
#### 图文分析
![](图片/QQ20251016-231641.png)
### 正确代码1
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

//正确代码
void GetMemory(char** p)
{
	//p指向str的地址
	*p = (char*)malloc(100);
}

void Test(void)
{
	char* str = NULL;
	//传入指针的地址
	GetMemory(&str);
	strcpy(str, "hallo world");
	printf(str);
	free(str);
	str = NULL;
}

int main()
{
	Test();
	return 0;
}
```
#### 图文分析
![](图片/QQ20251016-233426%201.png)
### 正确代码2
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char* GetMemory(char* p)
{
	p = (char*)malloc(100);
	return p; //返回地址
}

void Test(void)
{
	char* str = NULL;
	//接受地址
	str = GetMemory(str);

	strcpy(str, "hallo world");
	printf(str);
	free(str);
	str = NULL;
}

int main()
{
	Test();
	return 0;
}
```
## 习题2
---
### 错误代码
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

char* GetMemory(void)
{
	char p[] = "hello world";
	return p;
}
void Test(void)
{
	char* str = NULL;
	//str指向p地址
	str = GetMemory();
	//p地址销毁，str却指向p(野指针)
	printf(str);
}
int main()
{
	Test();
	return 0;
}
```
#### 图文分析
![](图片/QQ20251016-233426.png)
## 习题3
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

void Test(void)
{
	char* str = (char*)malloc(100);
	strcpy(str, "hello");
	//释放空间，str指向野指针，并不是空指针
	free(str);
	//应该加：str = NULL;
	if (str != NULL)
	{
		//非法访问内存
		strcpy(str, "world");
		printf(str);
	}
}

int main()
{
	Test();
	return 0;
}
```
# 6、柔性数组
---
也许你从来没有听说过**柔性数组**这个概念，但是它其实是存在的。C99中，结构体的最后应该元素允许是未知大小的·数组，这就叫做```柔性数组```成员。
- 结构体中，最后一个成员
- 最后一个成员是数组，数组没有指定大小
这个数组才是柔性数组！
例如：
```C
struct S
{
	char c;
	int n;
	int arr[0];//柔性数组
}

//有些编译器会写成
struct S
{
	char c;
	int n;
	int arr[];//柔性数组
}
```
## 6.1柔性数组的特点
- 结构体中的柔性数组成员前面必须至少应该其他成员，不然内存为0
- sizeof返回的这种结构大小不包括柔性数组的内存。
- 包含柔性数组成员的结构用malloc()函数的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

例如：
```C
typedef struct st_type
{
	int i;
	int a[0];//柔性数组成员
}type_a;
int main()
{
	printf("%d\n", sizeof(type_a));//输出的是4
	return 0;
}
```
## 6.2柔性数组的使用
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

struct S
{
	int n;
	int arr[0];
};

int main()
{
	//printf("%d", sizeof(struct S));4
	struct S* ps = (struct S*)malloc(sizeof(struct S) + 5 * sizeof(int));
	if (ps == NULL)
	{
		perror("malloc");
		return 1;
	}
	//赋值
	ps->n = 100;
	for (int i = 0; i < 5; i++)
	{
		ps->arr[i] = 1 + i;
	}
	//调整空间
	struct S* ptr = (struct S*)realloc(ps, sizeof(struct S) + 10 * sizeof(int));
	if (ptr != NULL)
	{
		ps = ptr;
	}

	//释放
	free(ps);
	ps = NULL;
	return 0;
}
```
## 6.3柔性数组的优势
![[图片/QQ20251017-092416.png]]
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

struct S
{
	int a;
	int* arr;
};

int main()
{
	//申请内存
	struct S* ps = (struct S*)malloc(sizeof(struct S));
	if (ps == NULL)
	{
		perror("malloc");
		return 1;
	}

	//给数组申请内存
	ps->arr = (int*)malloc(5 * sizeof(int));
	if (ps->arr == NULL)
	{
		perror("malloc");
		return 1;
	}

	//使用
	ps->a = 100;
	for (int i = 0; i < 5; i++)
	{
		ps->arr[i] = i + 1;
	}

	//调整数组大小
	int* ptr = (int*)realloc(ps, 10 * sizeof(int));
	if (ptr != NULL)
	{
		ps = ptr;
	}

	//使用
	for (int i = 5; i < 10; i++)
	{
		ps->arr[i] = 1 + i;
	}

	for (int i = 0; i < 10; i++)
	{
		printf("%d ", ps->arr[i]);
	}

	//释放
	free(ps);
	ps = NULL;

	return 0;
}
```
打印结果：
```
1 2 3 4 5 6 7 8 9 10 
```
上述代码1和代码2可以完成同样的功能，但是方法1的实现更好
1. 方便内存释放
2. 访问速度快一些