# 联合体的声明和创建
---
联合体和结构体区别
相同点：
- 由多个成员组成
不同点：
```C
#include<stdio.h>
//联合体类型的声明
union Un
{
	char c;
	int i;
};

int main()
{
	//联合体变量的定义
	union Un u = { 0 };
	//计算变量大小
	printf("%zd\n",sizeof(u));
	
	return 0;
}
```
输出结果：4
## 联合体的特点
---
联合体共用一块内存空间，联合体大小是最大成员的大小（因为联合体**至少**有能力保存最大的那个成员）。
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

union Un
{
	int a;
	char b;
};

int main()
{
	union Un u = { 0 };
	
	printf("%p\n", &u);
	printf("%p\n", &u.a);
	printf("%p\n", &u.b);

	return 0;
}
```
输出结果：
```
0000007549AFF784
0000007549AFF784
0000007549AFF784
```

## 联合体的地址变化
---
我们想进一步查看内存是如何变化的，可以通过调试查看地址变化
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

union Un
{
	int a;
	char b;
};
int main()
{
	union Un u = { 0 };

	u.a = 0x11223344;
	u.b = 0x55;

	return 0;
}
```
![](图片/控制流程图片/屏幕截图%202025-10-10%20093803.png)![](图片/控制流程图片/屏幕截图%202025-10-10%20093829.png)
可以用这个图更好看到内存如何变化的
![](图片/控制流程图片/bit-2025-10-10-09-42-45.png)

## 结构体和联合体内存图
---
![](图片/控制流程图片/bit-2025-10-10-09-46-11.png)

## 联合体大小计算
---
- 联合体的大小至少是最大成员的大小
- 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

union Un
{
	char a;
	int b;
};

int main()
{
	union Un u = { 0 };
	printf("%zd\n", sizeof(u));
	return 0;
```
输出结果：4

```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

union Un
{
	char a[5];//5个char类型
	int b;
};

int main()
{
	union Un u = { 0 };
	printf("%zd\n", sizeof(u));
	return 0;
}
```
输出结果：8

```C
union Un
{
	short a[7];
	int b;
};

int main()
{
	union Un u = { 0 };
	printf("%zd\n", sizeof(u));
	return 0;
}
```
输出结果：16

### 举例
---

使用联合体是可以节省空间的

比如，我们要搞一个活动，要上线一个礼品兑换单，礼品兑换单中有三种商品：图书、杯子、衬衫。每一种商品都有：库存量、价格、商品类型和商品相关的其他信息。
- 图书：书名、作者、页数
- 杯子：设计
- 衬衫：设计、可选颜色、可选尺寸

#### 直接用结构体
---
```C
struct gift_list
{
	//公共属性
	int stock_number;//库存量
	double price; //定价
	int item_type;//商品类型
	//特殊属性
	char title[20];//书名
	char author[20];//作者
	int num_pages;//页数
	char design[30];//设计
	int colors;//颜⾊
	int sizes;//尺⼨
};
```
上面结果虽然设计简单，用起来也方便，但是结构的设计中包含了所有的各种属性，这样使得结构体的大小就会偏大，会浪费内存。因为对于部分商品来说，只有部分属性是常用的。
![](图片/控制流程图片/bit-2025-10-10-10-14-33.png)
比如：

图书就不需要：设计、颜色、尺寸

#### 利用联合体
---
所有就可以把公共属性单独写出来，剩余属于各个商品本身的属性使用联合体，这样就可以介绍所需的内存空间，一定程度上节省了内存。
```C
struct gift_list
{
	int stock_number;//库存量
	double price; //定价
	int item_type;//商品类型

	union item{
		struct book
		{
			char title[20];//书名
			char author[20];//作者
			int num_pages;//页数
		};
		
		struct mug
		{
			char design[30];//设计
		};

		struct shirt
		{
			char design[30];//设计
			int colors;//颜⾊
			int sizes;//尺⼨
		};
	};
};
```
![](图片/控制流程图片/bit-2025-10-10-11-04-27.png)

#### 练习(判断1是什么端存放)
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int check()
{
	union Un
	{
		int x;
		char y;
	}s;
	s.x = 1;
	return s.y;
}

int main()
{
	int a = 1;
	int ret = check();

	if (ret == 1)
		printf("小端存放\n");
	else
		printf("大端存放\n");
	return 0;
}
```

# 枚举类型
---
## 枚举类型的声明
----
枚举的用处：
1. 一周的星期一到星期日
2. 性别：男、女、保密
3. 月份：1-12月
4. 三原色
这些数据的表示就可以使用枚举
```C
enum Day
{
	Mon,
	Tues,
	Wed,
	Thur,
	Fri,
	Sat,
	Sun
};

enum Sex
{
	MALE,
	FEMALE,
	SECRET
};

enum Color
{
	RED,
	GREEN,
	BLUE
};
```
以上定义的都是枚举类型，大括号{}中的内容是枚举类型的可能取值，也叫枚举常量。

这些可能取值都是有值的，默认从0开始，依次递增1，当然在声明枚举类型是也可以赋初值。
```C
enum Color//颜⾊
{
	RED=2,
	GREEN=4,
	BLUE=8
};
```

```C
enum Color//颜⾊
{
	RED, //0
	GREEN, //1
	BLUE //2
};
```

```C
enum Color//颜⾊
{
	RED = 3, //3
	GREEN, //4
	BLUE //5
};
```

```C
enum Color//颜⾊
{
	RED, //0
	GREEN = 4,//4
	BLUE //5
};
```

## 枚举类型的优点
---
我们可以使用define定义常量，为什么非要用枚举呢？
枚举的优点有很多：
1. 增加代码的可读性和可维护性
2. 和define定义的标识符比较枚举有类型检查，更加严谨
3. 便于调试，预处理阶段会删除define定义的符号
4. 枚举常量是遵循作用域规则的，枚举声明在函数内，只能在函数内使用

## 枚举类型的使用
---
 ```C
 enum Color
 {
	 RED = 1,
	 GREEN = 2,
	 BLUE = 4
 };
 
 enum Color clr = GREEN;//使⽤枚举常量给枚举变量赋值
 ```
 在C语言中可以那整数给枚举变量赋值，都是在C++中不行，C++的类型比较严格。