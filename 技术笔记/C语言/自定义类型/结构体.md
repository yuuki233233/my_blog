# 前言
---
在讲解操作符时，已经简单了解过结构体了，这篇文章将带你深入了解结构体是如何运用的。
# 一、结构体声明
---
## 1、语法形式
---
举例下面一个例子：
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

struct book
{
	char name[20];
	char author[20];
	float price;
	char id[13];
}b3, b4;//全局变量

struct book b2;//全局变量

int main()
{
	struct book b1;//局部变量

	return 0;
}
```

## 2、结构体的创建和初始化
---
### 2.1按照结构体成员顺序初始化
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//创建结构体
struct book
{
	char name[20];
	char author[20];
	float price;
	char id[13];
};

int main()
{
	//初始化1
	struct book b1 = { "PengGe_C Yuyan","PengGe",49.9, "QWE"};

	return 0;
}
```
### 2.2按照指定的顺序初始化
```C
//初始化2
struct book b2 = { .id = "QWE", .price = 8.8, .author = "PengGe", .name = "PengGe_C" };
```
## 3、结构体的输出
---
### 3.1单个输出和多个输出
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

struct book
{
	char name[20];
	char author[20];
	float price;
	char id[13];
};

int main()
{
	//按照结构体成员的顺序初始化
	struct book b1 = { "PengGe_C Yuyan","PengGe",49.9, "QWE"};
	//单个打印
	printf("%s ", b1.name);
	printf("%s ", b1.author);
	printf("%.1f ", b1.price);
	printf("%s ", b1.id);

	printf("\n");

	//一次性打印
	printf("%s %s %.1f %s", b1.name, b1.author, b1.price, b1.id);

	return 0;
}
```

打印结果是一样的：
![](图片/QQ20251007-213645.png)

## 4、结构中的特殊声明
---
### 4.1匿名结构体的使用
---
在声明结构的时候，可以不完全的声明
```C
struct
{
	char name;
	int age;
	int id;
}x={"zhangsan",22,11};
```
注意：匿名结构体只能使用一次

再比如：
```C
struct
{
	int a;
	char b;
	float c;
}x;

struct
{
	int a;
	char b;
	float c;
}a[20],*p;
```
上面的两个结构体在声明的时候省略掉了结构体标签。

### 4.2注意：
```C
//在上⾯代码的基础上，下⾯的代码合法吗？
p = &x;
```
1. 编译器会把上面的两个声明当成完全不同的两个类型，使用是非法的。
2. 匿名的结构体类型，如果没有对结构体类型重命名的华为，基本上只能使用一次。

## 5、结构的自引用
---
当我们要通过1找到2，3，4时该怎么去做？
![](图片/bit-2025-10-07-23-16-05.png)
### 5.1场景1：没有指针（错误方式）
---
```C
struct Node
{
	int data;//数据
	struct Node next;//错误！不能这样写
};
```
 比喻：
- 1号盒子(节点1)里要包含2号盒子(节点2)
- 2号盒子里又要包含3号盒子(节点3)
- 3号盒子里又要包含4号盒子(节点4)
- ...无限循环

**实际结构**：编译器会报错，因为结构体大小会变成无限大

### 5.2场景2：使用指针(正确方式)
---
```C
struct Node
{
	int data;//数据
	struct Node* next;//正确！使用指针
};
```
比喻：
1号盒子 ->[数据：1 | 地址条："2号盒子的位置"]
2号盒子 ->[数据：2 | 地址条："3号盒子的位置"]
3号盒子 ->[数据：3 | 地址条："4号盒子的位置"]
1号盒子 ->[数据：4 | 地址条："NULL（没有下一个）"]

### 5.3示例
---
```c
//没有指针：无限大小
struct Node {
    int data;           // 4字节
    struct Node next;   // 4字节 + 下一个Node的大小
}; //总大小 = 4 + (4 + (4 + (4 + ...))) = 无限大

//使用指针：固定大小
struct Node {
    int data;           // 4字节
    struct Node* next;  // 8字节（64位系统）
}; //总大小 = 4 + 8 = 12字节（固定）
```
# 二、结构体的缩写
---
我们在数据结构的书上常常看到这么写结构体
![](图片/bit-2025-10-07-22-57-05.png)
其实很好理解,typedef就是重命名(简化代码)，将写法复杂的struct Node改成了Node。

在结构体自引用的过程中，夹杂了typedef对匿名结构体类型重命名，也容易引入问题，如下列代码
```C
typedef struct
{
	int data;
	Node* next;
}Node;
```
这是错误的，因为Node时对前面的匿名结构体类型的重命名产生的，但是在匿名结构体内部提前使用Node类型来创建成员变量，这是不行的。正确的写法如下：
```C
typedef struct Node
{
	int data;
	struct Node* next;
}Node;
```

# 三、结构体内存对齐
---
前面讲了结构体的基本使用。接下来就是结构体内存对齐，这对于计算结构体的大小有着紧密关系。
## 6、对齐规则
---
首先得掌握结构体我得对齐规则：
1. 结构体得第一个成员会放到结构体变量起始位置，也就是偏移量为0得地址处。
2. 其他成员对齐到整数倍的地址处，对齐数=编译器默认对齐数与该成员变量大小的较小值
	- VS中对齐数默认是8
	- Linux中gcc没有默认对齐数，成员大小就是对齐数
3. 结构体总大小 = 最大对齐数的整数倍
4. 如果嵌套结构体，按照结构体与结构体变量所在的最大对齐数的整数倍处。将结构体所占的大小放入结构体变量中
接下来用几个示例来讲这4点是如何用的
## 6.1示例1
---
![](图片/QQ20251009-202454.png)
## 6.2示例2
---
![](图片/bit-2025-10-09-20-16-07.png)
## 6.3示例3
---
![](图片/bit-2025-10-09-20-17-38.png)
## 6.4示例4
---
![](图片/bit-2025-10-09-20-19-53.png)

# 四、为什么存在内存对齐?

⼤部分的参考资料都是这样说的：

1. 平台原因 (移植原因)：
- 不是所有的硬件平台都能访问任意地址上的任意数据的
- 某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常

2. **性能原因：**
数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
原因在于
- 为了访问未对齐的内存，处理器需要作两次内存访问
- 而对齐的内存访问仅需要⼀次访问
- 假设⼀个处理器总是从内存中取8个字节，则地址必须是8的倍数。如果我们能保证将所有的double类型的数据的地址都对齐成8的倍数，那么就可以用⼀个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中。

**总体来说**：结构体的内存对齐是拿空间来换取时间的做法。

那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：
那就让占用空间小的成员尽量集中在⼀起
```C
//例如：
struct S1 
{
	 char c1;
	 int i;
	 char c2;
};

 struct S2
 {
	 char c1;
	 char c2;
	 int i;
 };
```
s1和s2类型的成员一模一样，但是s1和s2所占空间的大小有了一些区别。

## 7.1修改默认对齐数
---
pragma是预处理指令，可以改变编译器的默认对齐数。
### 示例
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#pragma pack(1)//设置默认对⻬数为1
struct S
{
	char c1;
	int i;
	char c2;
};
#pragma pack()//取消设置的对齐数，还原为默认
int main()
{
	//输出的结果是什么？
	printf("%d\n", sizeof(struct S));
	return 0;
}
```
输出结果为：6
不用预处理指令输出结果：12

# 五、结构体传参
---
来看下列代码
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

struct Stu 
{
	int arr[100];
	int i;
	double d;
};

//非地址传参
void my_struct1(struct Stu x)
{
	for (int i = 0; i < 5; i++)
	{
		printf("%d ", x.arr[i]);
	}
	printf("\n");
	printf("%lf\n", x.d);
	printf("%d\n", x.i);
}

//地址传参
void my_struct2(const struct Stu* x)
{
	for (int i = 0; i < 5; i++)
	{
		//x->(指向)arr[i]
		printf("%d ", x->arr[i]);
	}
	printf("\n");
	printf("%lf\n", x->d);
	printf("%d\n", x->i);
}

int main()
{
	struct Stu s = { {1,2,3,4,5},100,23.33 };
	my_struct1(s);
	my_struct2(&s);

	return 0;
}
```
第一个和第二个打印的结果相同
![](图片/QQ20251009-214944.png)
那它们分别有什么优缺点呢？
- 在结构体无指针传参时，需要创建栈区，会有空间和时间上的浪费。
- 结构体指针传参时，地址的大小无非4/8个字节，即节省空间，又节省时间。
能用指针传参时，就尽量用指针传参。

# 六、结构体位段
---
## 6.1什么是位段
---
1.  位段的成员必须是int、unsigned、signed int，在C99中位段成员也可以是其他类型。
2. 位段的成员名后边有个冒号和一个数字。
```C
struct s
{
	int a:2;
	int a:5;
	int a:10;
}
```
## 6.2位段的内存分配
---
1. 和内存对齐一样，可以用来节省内存
2. 位段的成员可以是int，unsigned int，signed int，char等类型
3. 位段的空间是按照4个字节（int）或1个字节（char）开辟的
4. 标准C语言中，位段有很多不确定因素，要注意位段是不可以跨平台的使用
![](图片/QQ20251009-223610.png)
---

![](图片/QQ20251009-233858.png)
## 6.3位段的跨平台问题
---
1. int 位段被当成有符号数还是无符号数是不确定的。
2. 位段中最⼤位的数⽬不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
3. 位段中的成员在内存中从左向右分配，还是从右向左分配，标准尚未定义。
4. 当⼀个结构包含两个位段，第⼆个位段成员比较⼤，无法容纳于第⼀个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。

总结：
跟结构相比，位段可以达到同样的效果，并且可以很好的节省空间，但是有跨平台的问题存在。

## 6.4位段的应用
---
下图是⽹络协议中，IP数据报的格式，我们可以看到其中很多的属性只需要几个bit位就能描述，这里使用位段，能够实现想要的效果，也节省了空间，这样⽹络传输的数据报大小也会较小一些，对网络的畅通是有帮助的。
![](图片/WPS图片(1).png)
## 6.5位段使用的注意事项
---
位段的几个成员公用一个字节，这些成员的起始位置并不是某个字节的起始位置，那么这些成员是没有地址的。内存中每个字节分配一个地址，一个字节内部的bit位是没有地址的。使用不能对位段的成员使用&操作符，不能使用scanf给位段的成员输入值
只能是先输入放在一个变量中，然后赋值给位段的成员。
```C
struct A
{
	int _a : 2;
	int _b : 5;
	int _c : 10;
	int _d : 30;
};

int main()
{
	struct A a = { 0 };
	scanf("%d", &a._b);//这是错误的
	
	//正确示范
	int b = 0;
	scanf("%d", &b);
	sa._b = b;
	
	return 0;
}
```