# 前言
---
在讲解操作符中，解释了二进制，八进制，十进制，十六进制互相转换。这回就深入学习数据在内存是如何存储的。

# 整数在数据中的存储
---
## 有符号整数
---
有符号的整数，三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表
示“负”，最⾼位的一位是被当做符号位，剩余的都是数值位

## 二进制表达方式
---
整数二进制表达方式有三种：

原码：
- 为**整数的二进制**形式

反码：
- 正数：反码=原码
- 负数：符号位不变，其余位按位取反

补码：
- 正数：补码=原码
- 负数：补码=反码+1

## 计算机将整形存放二进制的好处
---
- 在计算机系统中，数值⼀律⽤补码来表⽰和存储。
- 原因在于，使用补码，可以将符号位和数值域统⼀处理；
- 同时，加法和减法也可以统⼀处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路

# 大小端字节序和字节序判断
---
![](图片/QQ20251006-105833.png)
1. 整数在内存中存储的是二进制补码
2. 在调试窗口中观察内存的时候，为了方便展示，显示的是十六进制的值
3. 存储的顺序是倒过来的

![](图片/QQ20251006-113056.png)
- 大端字节序存储：把一个数据的低位字节存储到高地址处，把高位字节存储到低地址处。
- 小段字节序存储：把一个数据的低位字节存储到低地址处，把高位字节存储到高地址处。

## 示例1：判断1是大端字节序存储还是小字端节序存储
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int my_num(int* x)
{
	//求单个字节，转化为char*
	char* n = (char*)x;
	//判断是哪个存储
	if (*n == 1)
	{
		return 1;
	}
	else
		return 0;
}

int main()
{
	int n = 1;
	int i = my_num(&n);
	if (i == 1)
		printf("小段字节存储");
	else
		printf("大端字节存储");

	return 0;
}
```

# 浮点数在数据中的存储
---
## 练习
---
![](图片/bit-2025-10-06-23-34-12.png)
- 当整数强转成浮数，取出来的结果不一样，所以整数和浮点型的存储方式不一样
- 当浮点数形式放在整数，取出来的结果也不一样，更加证明了存储方式不一样
## 浮点数的存储
---
根据国际标准IEEE（电气和电子工程协会） 754，任意⼀个二进制浮点数V可以表示成下⾯的形式：
![](图片/bit-2025-10-06-23-51-30.png)

---
![](图片/bit-2025-10-07-00-00-03.png)
举例来说：

十进制的5.0，写成二进制是101.0，相当于1.01×2^2 
那么，按照上⾯V的格式，可以得出S=0，M=1.01，E=2

十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×2^2 。那么，S=1，M=1.01，E=2

## 浮点数存储的过程
---
### 有效数字M
---
对于有效数字M和指数E，有着特别规定，前面说过，1≤M<2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分
以下图片为有效数字M的使用过程：
![](图片/QQ20251007-104438.png)

### 指数E
---
指数E的情况更加复杂，**E为⼀个无符号整数（unsigned int）**
- E如果为8位，取值：0~255
- E如果为11位，取值：0~2047
- 科学计数法中的E是可以出现负数的
- 规定中，必须加上中间值
![](图片/bit-2025-10-07-10-55-58.png)

## 浮点数取的过程
---
指数E从内存中取出还可以分成三种情况：
### E不全为0或不全为1
---
![](图片/QQ20251007-113450.png)

---
![](图片/QQ20251007-113546.png)
可以看出十六进制：40 B0 00 00在地址中的存放是00 00 B0 40，这种将高位放在低地址存放的行为称为小端字节存放。

### E全为0
---
浮点数的指数E=1~127（或者1~1023）即为真实值，有效数字M不再加上第一位1，而是还原为0.xxxxxxx的小数。这样做是为了无限接近于0。
```
0 00000000 0010000000000000000
```
## E全为1
---
这时候，如果有效数字M=0，表示+无穷大，-无穷小（正负取决于符号为S）
```
0 11111111 0001000000000000000
```

## 题目解析
---
下面，让我们回到一开始的练习
```C
#include <stdio.h>
int main()
{
	int n = 9;
	float *pFloat = (float *)&n;
	printf("n的值为：%d\n",n);
	printf("*pFloat的值为：%f\n",*pFloat);
	
	*pFloat = 9.0;
	printf("num的值为：%d\n",n);
	printf("*pFloat的值为：%f\n",*pFloat);
	
	return 0;
}
```
n首先为int类型，之后转为float类型时，他会认为自己指向float类型的数值
```
int类型解读
00000000 00000000 00000000 00001001
```
```
float类型解读
依次按照S、E、M二进制存储
0 00000000 0000000000000001001
```

当内存中的E为全0的时候，指数的E：1-127 = -126。
因为无限接近于，所以有效数字M，取出后不再加上第一位的整数1
```
(-1)^0 * 0.00000000000000000001001 * 2^-126
无限接近于0
```

接下来我以图片的方式来讲解
![](图片/QQ20251007-140429.png)

打印结果为：
![](图片/QQ20251007-140552.png)
结果与判断一致，大家懂了吗？