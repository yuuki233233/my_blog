# 1、指针的概念
---
- 比如我们常写的``` int a = 1;```在32位操作系统中占4个字节。在C语言中，如果想记录数据的话，那么需要一个变量来记录数据![](图片/控制流程图片/QQ20251010-220306.png)
- 如果想把a的地址保存的话，就需要一个变量来保存。因此我们会看到```int *p = &a;```

## 1.1指针的长度
---
```C
#include<stdio.h>

int main()
{
	printf("%zd\n",sizeof(int *));
	printf("%zd\n",sizeof(char *));
	printf("%zd\n",sizeof(double *));
	printf("%zd\n",sizeof(float *));
	printf("%zd\n",sizeof(short *));
	
	return 0;
}
```
在64位环境中，输出的结果为：
![](图片/控制流程图片/QQ20251010-221151.png)
在64位环境中，所有的指针都是占8个字节。
在32位环境中，所有的指针都是占4个字节。

## 1.2指针与变量
---
![](图片/控制流程图片/QQ20251010-222554.png)

### 解引用* 的两种含义
---
![](图片/控制流程图片/QQ20251010-222600.png)
### 取地址&的含义
---
C语言中规定，不管变量占多少个字节，是取它最前面的地址。
- 用0x100来表示整形a的首地址
- 用0x200表示字符型ch的首地址
- 使用地址时，类型要相同，不然会报错
```C
char ch = 'a';
int *q = &ch; //类型不兼容
```
### 其他类型指针
---
不同类型中，指针指向的类型也不同，这次我们看看char类型的指针是如何表示的
![](图片/控制流程图片/QQ20251010-223452.png)
保存地址需要指针，保存着字符型的地址。

int* 和char* 步长（单位）不一样
```C
#include<stdio.h>

int main()
{
	int num = 1;
	int *p = &num;
	*p = 100;   //等价于num = 100
	printf("num = %d\n", num);
	
	char ch = 'a';
	//int *q = &ch; //类型不兼容
	char *q = &ch;
	printtf("ch = %c", *q);
	return 0;
}
```
打印结果：num = 100；ch = 'a';

## 1.3打印地址
---
```C
#include<stdio.h>

int main()
{
	int num = 1;
	int *p = &num;
	*p = 100;   //等价于num = 100
	
	char ch = 'a';
	char *q = &ch;
	
	printf("%p\n", p);
	printf("%p\n", q);
	return 0;
}
```
地址结果为：
```
0x7ffd5d903424
0x7ffd5d903423
```

####  地址步长
```C
//如果让指针+1
printf("%p\n", q);
printf("%p\n", q + 1);
printf("%p\n", p);
printf("%p\n", p + 1);
```
输出结果：
```
char类型地址+1
0x7fffd75878b3
0x7fffd75878b4

int类型地址+4
0x7fffd75878b4
0x7fffd75878b8
```

p指向的是整数，整数占4个字节，所有p+1加4个字节
q指向的是字符，字符占1个字节，所有q+1加1个字节
![](图片/控制流程图片/QQ20251010-225639.png)

# 2、指针作为函数参数
---
指针在传参时，因为地址所占的内存小，所以会很方便。而用结构体传参，需要的空间很大，但如果时用指针传入结构体的地址，也才花8个字节，效率就会大大增高。
## 2.1指针的应用
---
### 交换数字
---
##### 用变量交换
---
我们用函数来对a，b的值来交换，那能不能交换呢？
![](图片/控制流程图片/QQ20251010-230841.png)
很显然，只用函数是不能够交换a和b得值的。因为函数间的数据传输是单向的。

这是为什么呢？我将用画图来简单解释![](图片/控制流程图片/QQ20251014-072909%201.png)

##### 用地址来交换
---
我们在函数中传入a、b的地址，通过指针来找到a、b的地址再进行修改。
![](图片/控制流程图片/QQ20251014-073210.png)
这是为什么呢？
![](图片/图片/QQ20251014-073801.png)
1. 通过地址来修改a、b的值。此时a=2，b=1
2. 然后释放空间，传入a、b地址的函数就没了

**这就是通过地址，间接把a、b的值做了交换**

# 3、指针运算
---
## 3.1指针可以赋值运算
---
![](图片/图片/QQ20251014-075201.png)
1. * pa = &a，声明pa是个指针，且指向a的地址
2. * pb，声明pb是个指针。pb = pa，指把pa地址赋值给pb，如上图。
### 经典笔试题
---
![](图片/图片/QQ20251014-081101.png)
px指向空指针
## 3.2字符串函数strcpy
---
[[字符函数#6.3 strcpy函数的模拟实现|模拟实现strcpy]]

# 4、空指针和野指针
---
在写代码中，我们会经常遇到野指针，我们接下来看一下什么是野指针，遇到野指针会出现什么问题
## 4.1野指针
---
```C
#include<stdio.h>

int main()
{
	//只定义不初始化，指针会随机指向一个我们不知道的内存
	int *p;
	//段错误，访问了不能访问的内存
	*p = 100;
	
	return 0;
}
```

### 如何避免野指针
---
#### 利用空指针
---
当我们不知道初始化什么比较好，随手写成一个空指针就可以
```C
#include<stdio.h>
#include<stdlib.h>

int main()
{
	//*p指向一个0的内存(NULL = 0)
	int *p = NULL;
	*p = 100;
	
	return 0;
}
```

#### 系统分配的内存
---
```C
//int类型，系统会分配4个字节
int a;
//p1指向a的内存
int *p = &a；
```

#### 用户申请内存(堆内存)
---
```C
//动态内存分配，分配32个字节
malloc(32)
//编译器不知道保存的是什么类型的数据，所有干脆返回void类型
//当我们确定是一个类型：比如char类型，就要强转成char类型，如下：
char *str = (char *)malloc(32);

//释放内存
free(str)//不释放的话，内存泄漏
str = NULL;//不为空指针话，就会指向释放掉的内存(变成野指针)

return 0;
```
# 5、笔试训练
---
去掉字符串中的空格。（输入abcd ef g hijk  输出 abcdefghijk）
## 错误1
---
![](图片/图片/QQ20251014-092957.png)
但是这个代码还有个问题当我们输入```hallo world```只会输出```hallo```遇到空格就结束

## 写法1
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<stdlib.h>

int main()
{
	char* str = (char*)malloc(128);

	//遇到\0结束，遇到空格不结束(冷门)
	scanf("%[^\n]", str);

	printf("%s\n", str);

	return 0;
}
```
## 写法2
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<stdlib.h>

int main()
{
	char* str = (char*)malloc(128);

	//利用函数
	gets(str);

	printf("%s\n", str);

	return 0;
}
```
注意：
- 这个函数在windows系统中会报错，但是可以解决问题
- 在Linux系统是支持的
## 写法3
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<stdlib.h>

int main()
{
	char* str = (char*)malloc(128);

	char ch;
	int i = 0;
	while((ch = getchar()) != '\n')
	{
		*(str + i++) = ch;
	}

	printf("%s\n", str);

	return 0;
}
```
## 完整代码
---
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<stdlib.h>

void delete_space(char* s)
{
	while(*s != '\0')
	{
		*s = *(s + 1);
		s++; 
	}
}

int main()
{
	char* str = (char*)malloc(128);

	char ch;
	int i = 0;
	while((ch = getchar()) != '\n')
	{
		*(str + i++) = ch;
	}
	
	char *begin = str;
	
	while(*str != '\0')
	{
		if(*str == ' ')
		delete_space(str);
		else
		str++;
	}

	printf("%s\n", begin);

	return 0;
}
```