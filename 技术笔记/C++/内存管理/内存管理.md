# 一、C/C++内存管理
>![](图片/QQ20251202-105743.png)
>1. `栈`：存储非静态局部变量、函数参数、返回值等，空间自动管理，向下增长
>2. `内存映射段`：用于高效 I/O 操作和进程间共享内存
>3. `数据段`：全局数据、静态数据
>4. `代码段`：可执行代码、常量

# 二、C语言中存管理
C语言使用`malloc/calloc/realloc/free`进行动态内存管理
```cpp
void test()
{
    int* p1 = (int*)malloc(4 * sizeof(int));  // 分配空间，不初始化
    int* p2 = (int*)calloc(4, sizeof(int));   // 分配空间并初始化为0
    int* p3 = (int*)realloc(p2, 10 * sizeof(int)); // 重新分配空间
    
    free(p1);
    free(p3);  // realloc后只需释放新指针
}
```
>1. malloc在堆上手动申请个空间
>2. calloc在手动申请空间的基础上进行初始化为0
>3. realloc申请比之前申请更大的新空间，将之前申请的旧空间拷贝到新空间中，然后再销毁旧空间
# 三、C++内存管理方式
## 1、new和delete操作我自定义类型
### 1.1 内置类型
```cpp
int main()
{
    // 基本用法
    int* p1 = new int;         // 分配单个int空间
    int* p2 = new int[10];     // 分配10个int的数组
    
    // 初始化
    int* p3 = new int(0);      // 分配并初始化为0
    int* p4 = new int[10]{0};  // 数组初始化，剩余元素为0
    int* p5 = new int[10]{1,2,3,4,5}; // 部分初始化
    
    // 释放空间
    delete p1;
    delete[] p2;
    delete p3;
    delete[] p4;
    delete[] p5;
    return 0;
}
```
### 1.2 类类型
对于自定义类型，`new`和`delete`会自动调用构造函数和析构函数：
```cpp
//类类型
//----------------------------------------------------------------------------
#include<iostream>
using namespace std;

class A
{
public:
	A(int a1, int a2 = 0)
		:_a1(a1)
		,_a2(a2)
	{
		cout << "A(int a1 = 0, int a2 = 0)" << endl;
	}

	A(const A& aa)
		:_a1(aa._a1)
	{
		cout << "A(const A& aa)" << endl;
	}

	A& operator=(const A& aa)
	{
		_a1 += 100;

		return *this;
	}

private:
	int _a1 = 1;
	int _a2 = 2;
};

int main()
{
	A* p1 = new A(1); //必须默认构造
	A* p2 = new A(2, 2);
	//A* p3 = new A[3]; //默认默认构造则报错


	//第一种写法
	A aa1(1, 1);
	A aa2(2, 2);
	A aa3(3, 3);
	A* p3 = new A[3]{ aa1, aa2, aa3 };//拷贝构造

	//第二种写法:匿名构造
	//编译器直接优化成直接构造
	A* p4 = new A[3]{ A(1, 1), A(2, 2), A(3, 3) };

	//第三种写法：隐式类型转换
	//编译器直接优化成直接构造
	A* p5 = new A[3]{ {1,1},{2,2},{3,3} };

	return 0;
}
//----------------------------------------------------------------------------

```
### 1.3 链表类型
```cpp
//----------------------------------------------------------------------------
struct ListNode
{
	int val;
	ListNode* next;

	ListNode(int x)
		:val(x)
		,next(nullptr)
	{ }
};

int main()
{
	//与C语言的区别是：自动调用构造函数和析构函数
	A* p1 = new A;
	A* p2 = new A(1);

	delete p1;
	delete p2;

	//用new申请类类型和自定义类型的空间：自动初始化与析构
	ListNode* n1 = new ListNode(1);
	ListNode* n2 = new ListNode(1);
	ListNode* n3 = new ListNode(1);
	ListNode* n4 = new ListNode(1);
	n1->next = n2;
	n2->next = n3;
	n3->next = n4;

	return 0;
}
//----------------------------------------------------------------------------
```

# 四、operator new与operator delete函数
>`new`和`delete`时用户进行`动态内存申请和释放的操作符`，`operator new`和`operator delete`时系统提供的`全局函数`，`new在底层调用operator new`全局函数来申请空间，`delete在底层通过operator delete`全局函数来释放空间。
>`operator new实际也是通过malloc来申请空间`，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。`operator delete最终是通过free来释放空间的`
## 1、捕捉异常
```cpp
//----------------------------------------------------------------------------
void func()
{
	int n = 1;
	while (1)
	{
		void* p1 = new char[1024 * 1024];
		cout << p1 << "->" << n << endl;
		++n;
	}
}

int main()
{
	try
	{
		func();
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;
	}

	return 0;
}
//----------------------------------------------------------------------------
```
# 五、new和delete的实现原理
## 1、内置类型
>如果申请的是内置类型的空间，`new和malloc，delete和free基本类似`，不同的地方是：`new/delete申请和释放的是单个元素的空间`，`new[]和delete[]申请的连续空间`，而且`new在申请空间失败是会抛异常，malloc会返回NULL`。

```cpp
#include<iostream>
using namespace std;

int main()
{
	//内置类型
	// 
	// 
	//不会报错(内核是)：
	//new operator[]最终调用malloc
	//delete operator[]最终调用free
	int* p1 = new int[10];  // -> malloc
	delete p1;				// -> free
	free(p1);
	 
	return 0;
}
```
## 2、自定义类型
>- new的原理
>	- 1. 调用operator new函数申请空间
>	- 2. 在申请的空间上执行构造函数，完成对象的构造
>- delete的原理
>	- 1. 在空间上执行析构函数，完成对象中资源的清理工作
>	- 2. 调用operator delete函数释放对象的空间
>- new T[N]的原理
>	- 1. 调用operator new[]函数，在operator new[]中实现用operator new函数完成N个对象空间上的申请
>	- 2. 在申请的空间上执行N次构造函数
>- delete[]的原理
>	- 1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理
>	- 2. 调用operator delete[]释放空间，实际上operator delete[]中调用operator delete来释放空间

```cpp
#include<iostream>
using namespace std;

class A
{
public:
	~A()
	{
		cout << "~A()" << endl;
	}

private:
	int _a1 = 1;
	int _a2 = 2;
};

class B
{
private:
	int _b1 = 1;
	int _b2 = 2;
};


int main()
{
	//自定义类型
	// 
	// 
	//因为B* p1没有调用析构函数，析构被编译器优化掉
	//因为没有析构，前面没有开4个字节，一共80个字节且释放地方相同，所以可以正常释放
	B* p1 = new B[10];
	delete p1;

	//这里由于调用了析构函数，在创建的80字节内存前加了4字节，一共有84字节
	//这里只用delete却没有用delete[]，会让p2指向第80字节，释放空间时因为释放位置不对而崩溃
	A* p2 = new A[10];
	
	delete p2;
}
```
# 六、malloc/free和new/delete的区别

| 特性    | malloc/free | new/delete   |
| ----- | ----------- | ------------ |
| 性质    | 函数          | 操作符          |
| 初始化   | 不初始化        | 可初始化         |
| 参数    | 需要手动计算大小    | 只需指定类型       |
| 返回值   | void*，需强转   | 具体类型指针       |
| 错误处理  | 返回 NULL     | 抛异常          |
| 自定义类型 | 只分配 / 释放空间  | 会调用构造 / 析构函数 |
>**共同点是：**
>1. 都是从堆上申请空间，并且需要用用户手动释放。不同的地方是：
>
>**不同点是：**
>1. malloc和free是函数，new和delete是操作符
>2. malloc申请的空间不会初始化，new可以初始化
>3. malloc申请空间时，需要手动计算空间大小并传替，new只需在其后跟上空间的类型即可，如果时多个对象，[]中指定对象个数即可
>4. malloc的返回值时void*，在使用时必须强转，new不需要，因为new后跟的是空间类型
>5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，都是new需要捕获异常
>6. 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理释放