>前言
>在上篇讲解了list的模拟实现，遇到了`迭代器失效、拷贝构造、指针指向逻辑`等问题。
>在`string、vector、list`中运用过许多函数接口，而这篇会跳过函数接口的使用，直接向下解决`栈和队列`的模拟实现

# 一、deque的简单介绍
## 1.1deque的原理介绍
`deque(双端队列)：是一种双开口的"连续"空间的数据结构`，双开口的含义是：可以在头尾两端进行插入和删除操作，且时间复杂度为O(1)，与vector比较，头插效率高，不需要搬移元素；与list比较，空间利用率比较高。
![](图片/deque0.png)

deque并不是真正连续的空间，而是由一段段连续的小空间拼接而成的，实际deque类似于一个动态的二维数组，双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上，因此deque的迭代器设计就比较复杂，如下图所示：
![](图片/deque01.png)
那deque是如何借助其迭代器维护其假想连续的结构呢？
![](图片/deque.png)
## 1.2deque的缺陷
>比较于vector：
>1. 头插和删除，不需要移动元素，效率特别搞
>2. 扩容时，不需要移动大量元素
>
>比较于list：
>1. 底层是练习空间，空间利用率比较高

>缺陷：
>1. 不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下

而序列式场景中，可能需要经常遍历，因此在实际中，需要线性结构时，大多数情况下优先考虑vector和list，deque的应用并不多，而目前能看到的一个应用就是，STL用其作为stack和queue的底层数据结构。
## 1.3deque作为stack和queue的底层默认容器
 >1. stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。
 >2. 在stack中元素增长时，deque比vector的效率高(扩容时不需要搬移大量数据)；queue中的元素增长时，deque不仅效率高，而且内存使用率高。
# 二、stack和queue的整体框架
 `stack、queue`的结构一样，本质上都是运用数组实现结构，不同点就是`stack(栈)`先进后出，`queue(队列)`先进先出
 ```cpp
 // Stack.h
#pragma once
#include<deque>

namespace yuuki
{
	// deque就是vector(顺序表)+list(链表)的粘合剂
	template<class T, class Container = deque<T>>
	class stack
	{
	public:
		// 插入接口
		void push(const T& x)
		{
			_con.push_back(x);
		}
		
		// 删除接口
		void pop()
		{
			_con.pop_back();
		}
		
		// 返回容器第最后个元素的引用
		const T& top() const
		{
			return _con.back();
		}

		// 有效元素
		size_t size() const
		{
			return _con.size();
		}

		// 判空
		bool empty() const
		{
			return _con.empty();
		}

	private:
		// 容器(deque本质上是数组)
		Container _con;
	};
}
 ```

```cpp
// queue.h
#pragma once
#include<deque>

namespace yuuki
{
	template<class T, class Container = deque<T>>
	class queue
	{
	public:
		// 插入接口
		void push(const T& x)
		{
			_con.push_back(x);
		}
		
		// 删除接口
		void pop()
		{
			_con.pop_front();
		}

		// 返回容器第一个元素的引用
		const T& front() const
		{
			return _con.front();
		}

		// 返回容器第最后个元素的引用
		const T& back() const
		{
			return _con.back();
		}

		// 有效元素
		size_t size() const
		{
			return _con.size();
		}

		// 判空
		bool empty() const
		{
			return _con.empty();
		}

	private:
		Container _con;
	};
}
```
# 三、priority_queu的介绍和使用
## 3.1priority_queu的介绍
>1. 优先队列是一种容器适配器，根据严格的弱排序标准，它的第一个元素总是它所包含的元素中最大的。
>2. 此上下文类似于堆，在堆中可以随时插入元素，并且只能检索最大堆元素(优先队列中位于顶部的元素)。
>3. 优先队列被实现为容器适配器，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特定的成员函数来访问其元素。元素从特定容器的“尾部”弹出，其称为优先队列的顶部。
>4. 底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应该可以通过随机访问迭代器访问，并支持以下操作：
>	- `empty()`：检测容器是否为空
>	- `size()`：返回容器中有效元素个数
>	- `front()`：返回容器中第一个元素的引用
>	- `push_back()`：在容器尾部插入元素
>	- `pop_back()`：删除容器尾部元素
>5. 标准容器类`vector和deque`满足这些需求。默认情况下，如果没有为特定的`priority_queue`类实例化指定容器类，则使用vector。
>6. 需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数`make_heap、push_heap和pop_heap`来自动完成此操作。

## 3.2priority_queu的使用
优先级队列默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue。注意：默认情况下priority_queue是大堆。

| 函数声明                                        | 接口说明                          |
| ------------------------------------------- | ----------------------------- |
| priority_queue()/priority_queue(first,last) | 构造一个空的优先级队列                   |
| empty( )                                    | 检测优先级队列是否为空，是返回true，否则返回false |
| top( )                                      | 返回优先级队列中最大(最小元素)，即堆顶元素        |
| push(x)                                     | 在优先级队列中插入元素x                  |
| pop()                                       | 删除优先级队列中最大(最小)元素，即堆顶元素        |
注意：
1. 默认情况下，priority_queue是大堆
```cpp
#include <vector>
#include <queue>
#include <functional> // greater算法头文件

void Test()
{
	// 默认情况下，创建的是大堆，其底层按照小于号比较
	vector<int> v{3,6,3,8,0,9,5,1};
	priority_queue<int> q1;
	
}
```