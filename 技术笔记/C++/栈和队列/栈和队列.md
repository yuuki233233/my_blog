>前言
>在上篇讲解了list的模拟实现，遇到了`迭代器失效、拷贝构造、指针指向逻辑`等问题。
>在`string、vector、list`中运用过许多函数接口，而这篇会跳过函数接口的使用，直接向下解决`栈和队列`的模拟实现

# deque的简单介绍
## deque的原理介绍
`deque(双端队列)：是一种双开口的"连续"空间的数据结构`，双开口的含义是：可以在头尾两端进行插入和删除操作，且时间复杂度为O(1)，与vector比较，头插效率高，不需要搬移元素；与list比较，空间利用率比较高。
![](图片/deque0.png)

deque并不是真正连续的空间，而是由一段段连续的小空间拼接而成的，实际deque类似于一个动态的二维数组，双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上，因此deque的迭代器设计就比较复杂，如下图所示：
![](图片/deque01.png)
那deque是如何借助其迭代器维护其假想连续的结构呢？
![](图片/deque.png)
## deque的缺陷
>比较于vector：
>1. 头插和删除，不需要移动元素，效率特别搞
>2. 扩容时，不需要移动大量元素
>
>比较于list：
>1. 底层是练习空间，空间利用率比较高
# stack和queue的整体框架
 `stack、queue`的结构一样，本质上都是运用数组实现结构，不同点就是`stack(栈)`先进后出，`queue(队列)`先进先出
 ```cpp
 // Stack.h
#pragma once
#include<deque>

namespace yuuki
{
	// deque就是vector(顺序表)+list(链表)的粘合剂
	template<class T, class Container = deque<T>>
	class stack
	{
	public:
		// 插入接口
		void push(const T& x)
		{
			_con.push_back(x);
		}
		
		// 删除接口
		void pop()
		{
			_con.pop_back();
		}
		
		// 取尾元素接口
		const T& top() const
		{
			return _con.back();
		}

		// 取大小接口
		size_t size() const
		{
			return _con.size();
		}

		// 判空接口
		bool empty() const
		{
			return _con.empty();
		}

	private:
		// 容器(deque本质上是数组)
		Container _con;
	};
}
 ```