# 一、类定义格式
>- class为定义类的关键字，Stack为类的名字，0中为类的主体，注意类定义结束时后面分号不能省略。类体中内容称为类的成员：类中的变量称为类的属性或成员变量；类中的函数称为类的方法或者成员函数。
>- 为了区分成员变量，一般习惯上成员变量会加一个特殊标识，如成员变量前面或者后面加或者m开头，注意C++中这个并不是强制的，只是一些惯例，具体看公司的要求。
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	//为了区分成员变量，一般习惯是成员变量
	//会加一个特殊标识，如_ 或者 m开头
	int _year; // year_   m_year
	int _month;
	int _day;
};

int main()
{
	Date d;
	d.Init(2025, 11, 24);

	return 0;
}
```
>C++中struct也可以定义类，C++兼容C中struct的用法，同时struct升级成了类，明显的变化是struct中可以定义函数，一般情况下我们还是推荐用class定义类。

```cpp
#include<iostream>
using namespace std;

//C++升级struct升级成了类
//1、类里面可以定义函数
//2、struct名称就可以代表类型

//C++兼容C中struct的用法
typedef struct ListNodeC
{
	struct ListNOdeC* next;
	int val;
}LTNode;

//C++中不再需要typedef，ListNodeCPP就可以代表类型
struct ListNodeCPP
{
	//C++中，struct可以定义函数
	void Init(int x)
	{
		next = nullptr;
		val = x;
	}

	//不需要用struct ListNodeCPP
	ListNodeCPP* next;
	int val;
};

int main()
{
	return 0;
}
```
>定义在类面的成员函数默认为inline。
# 二、访问限定符
>- C++一种实现封装的方式，用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其**接口**提供给外部的用户使用。
>- public修饰的成员在类外可以直接被访问；protected和private修饰的成员在类外不能直接被访问，protected和private是一样的，以后继承章节才能体现出他们的区别。
>- 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止，如果后面没有访问限定符，作用域就到即类结束。
>- class定义成员没有被访问限定符修饰时默认为private，struct默认为public。一般成员变量都会被限制为private/protected，需要给别人使用的成员函数会放为public。
```cpp
class Stack
{
	//默认私有
	void Push(int x)
	{ }
	void Pop()
	{ }
	int Top()
	{ }

	int* a;
	int top;
	int capacity;
};

int main()
{
	Stack st;
	//因为是私有，无法访问
	st.Push();
	return 0;
}
```


```cpp
class Stack
{
//公有（可以访问）
public:
	void Push(int x)
	{ }
	void Pop()
	{ }
	int Top()
	{ }

//私有（不能访问）
private:
	int* a;
	int top;
	int capacity;
};

int main()
{
	//因为是公有，可以访问
	Stack st;
	st.Push(4);

	return 0;
}
```

```cpp
class Stack
{
	//尽管下面是公有的，上面也默认私有
	void Destory();

//公有（可以访问）
public:
	void Push(int x)
	{ }
	void Pop()
	{ }
	int Top()
	{ }

//私有（不能访问）
private:
	int* a;
	int top;
	int capacity;
};
```
# 三、类域
>- 类定义了一个新的作用域，类的所有成员都在类的作用域中，在类体外定义成员时，需要使用：作用域操作符指明成员属于哪个类域。
>- 类域影响的是编译的查找规则，下面程序中Init如果不指定类域Stack，那么编译器就把Init当成全局函数，那么编译时，找不到array等成员的声明/定义在哪里，就会报错。指定类域Stack，就是知道Init是成员函数，当前域找不到的array等成员，就会到类域中去查找。
```cpp
#include<iostream>
using namespace std;

class Stack
{
public:
	//成员函数
	void Init(int n = 4);

private:
	//成员变量
	int* array;
	size_t capacity;
	size_t top;
};

//声明和定义分离，需要指定类域
void Stack::Init(int n)
{
	array = (int*)malloc(sizeof(int) * n);
	if (nullptr == array)
	{
		perror("malloc fail");
		return;
	}

	capacity = n;
	top = 0;
}

int main()
{
	Stack st;
	st.Init();

	return 0;
}
```
# 四、实例化
## (1)实例化概念
>- 在类中创建对象的过程，称为实例化对象
>- 类是对象的一种抽象描述，是一模一样的，限定了类有哪些成员变量，这些成员变量只是声明，没有分配空间，用类实例化出对象时，才会分配空间
>- 一个类中可以实例化多个对象，实例化出的对象占用实际的物理空间，存储类成员变量。

![](图片/QQ20251125-202823.png)
```cpp
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

private:
	//这里只是声明，没有开辟空间
	int _year;
	int _month;
	int _day;
};

int main()
{
	// Date类实例化出对象d1和d2
	Date d1;
	Date d2;

	d1.Init(2025, 5, 20);
	d1.Print();

	d2.Init(2026, 5, 20);
	d2.Print();

	return 0;
}
```
## (2)对象大小
**内存对齐规则**
>- 第一个成员在结构体偏移量为0的地址处
>- 其他成员变量对齐到某个对齐数的整数倍的地址处
>- 对齐数 = 编译器默认的对齐数与该成员大小的较小值
>- VS中对齐数默认为8
>- 结构体总大小：最大对齐数(所有变量类型最大的与默认对齐参数取最小)的整数倍
>- 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;

class A
{
public:
	void Print()
	{
		cout << _ch << endl;
	}

private:
	char _ch;
	int _i;
};

class B
{
	void Print() {};
};

class C
{ };

int main()
{
	A a;
	B b;
	C c;

	cout << sizeof(a) << endl; //8
	cout << sizeof(b) << endl; //1
 	cout << sizeof(c) << endl; //1

	return 0;
}
```
成员变量B和C对象的大小是1，这是为了占位标识对象存在，所以给了1字节。
# 五、this指针
>- 编译后，会在形参第一位置增加一个当前类型的this指针。`void Init(Date* const this, int year, int month, int day)`
>- 类的成员函数中访问成员变量，本质都是通过this指针访问的。`this->_year = year`
>- this指针可以在函数内自行使用，也可以不加(编译器会主动处理)

```cpp
class Date
{
public:
	// void Init(Date* const this, int year, int month, int day)
	void Init(int year, int month, int day)
	{
		//类里的函数里面加指针this解引用，两种都可行
		this->_year = year;
		this->_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

private:
	//这里只是声明，没有开辟空间
	int _year;
	int _month;
	int _day;
};

int main()
{
	// Date类实例化出对象d1和d2
	Date d1;
	Date d2;

	// d1.Init(&d1, 2024, 3, 31);
	d1.Init(2025, 5, 20);
	d1.Print();

	d2.Init(2026, 5, 20);
	d2.Print();

	return 0;
}
```
# 六、综合题目
## 1、
```cpp
class A
{
public:
	void Print()
	{
		cout << "A::Print()" << endl;
	}

private:
	int _a;
};

int main()
{
	A* p = nullptr;
	p->Print();  //A::Print()

	return 0;
}
```
p为A类的指针，由于`int _a`在类的私有中，只是一个声明，不会开辟空间，所以`p->print()`中正常运行。
## 2、
```cpp
class A
{
public:
	void Print()
	{
		cout << "A::Print()" << endl;
		//这里给_a开辟空间
		cout << _a << endl;
	}

private:
	int _a;
};

int main()
{
	A* p = nullptr;
	p->Print(); //程序崩溃

	return 0;
}
```
在Print函数中，输出`_a`时，要为`_a`申请空间，`p->print()`类型于空指针解引用。
## 3、
this指针存在内存的`栈`区域
# 七、C++和C语言实现Stack对比
面向对象三大特征：封装、继承、多态，我们先了解一下封装。
- C++中数据和函数都放到了类里面，通过访问限定符进行了限制，不能再随意通过对象直接修改数据，这是C++封装的一种体现，这个是最重要的变化。这里的封装的本质是一种更严格规范的管理，避免出现乱访问修改的问题。当然封装不仅仅是这样的，我们后面还需要不断的去学习
- C++中有一些相对方便的语法，比如Init给的缺省参数会方便很多，成员函数每次不需要传对象地址，因为this指针隐含的传递了，方便了很多，使用类型不再需要typedef用类名就很方便
- 在我们这个C++入门阶段实现的Stack看起来变了很多，但是实质上变化不大，本质上还是一样的
