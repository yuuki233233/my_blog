# 一、类的默认成员函数
编译器会自动生成的成员函数称为默认成员函数。一个类，不写的情况下编译器会默认生成以下6个默认成员函数。另外在C++11中，增加了两个默认成员函数，移动构造和移动赋值。默认成员函数从两方面学习：
1. 我们不写时，编译器默认生成的函数行为是啥？满足我们的需求吗？
2. 编译器默认生成的函数不满足我们的需求，那如何自己实现？
![](图片/图片/QQ20251125-223740.png)
# 二、构造函数
**构造函数主要任务是对象实例化时初始化对象**。就像每次写栈或队列时需要初始化`Stack Init()`、`Queue Init()`，用了构造函数就不需要写这一步。
>**构造函数的特点：**
>1. 函数名与类名相同：类`class Stack`，类中的函数`Stack()`
>2. 无返回值。`也无void`
>3. 对象实例化时系统会自动调用对应的构造函数
>4. 构造函数可以重载
>5. 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成
>6. **无参构造函数、全缺省构造函数、我们不写构造时编译器默认生成的构造函数，都叫做默认构造函数。但是这三个函数有且只有一个存在，不能同时存在**。无参构造函数和全缺省构造函数虽然构成函数重载，但是调用时会存在歧义。要注意默认构造函数不止是编译器默认生成那个叫默认构造，实际上无参构造函数、全缺省构造函数也是默认构造，总结一下就是不传实参就可以调用的构造就叫默认构造
>7. 我们不写，编译器默认生成的构造，对内置类型成员变量的初始化没有要求，也就是说是是否初始化是不确定的，看编译器。**对于自定义类型成员变量，要求调用这个成员变量的默认构造函数初始化。如果这个成员变量，没有默认构造函数，那么就会报错，我们要初始化这个成员变量，需要用初始化列表才能解决**

## 1、构造函数的基本运用
```cpp
class Date
{
public:
	// 1.无参构造函数
	Date()
	{
		_year = 1;
		_month = 1;
		_day = 1;
	}

	// 2.带参构造函数
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	////3. 全缺省构造函数
	//Date(int year = 1, int month = 1, int day = 1)
	//{
	//	_year = year;
	//	_month = month;
	//	_day = day;
	//}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	//如果留下三个构造中的第二个带参构造，第一个和第三个注释掉

	Date d1; // 调用默认构造函数
	d1.Print(); // 输出：1/1/1

	Date d2(2025, 11, 25); // 调用带参的构造函数
	d2.Print();

	//注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则编译器无法
	//区分这里是函数声明还是实例化对象

	/*Date d3(2007, 6, 18);
	d3.Print();*/

	return 0;
}
```
## 2、队列中的特殊运用
```cpp
typedef int STDataType;
class Stack
{
public:
	//默认构造函数，若改成int n则不是默认构造函数
	Stack(int n = 4)
	{
		_a = (STDataType*)malloc(sizeof(STDataType) * n);
		if (nullptr == _a)
		{
			perror("malloc fail");
			return;
		}

		_capacity = n;
		_top = 0;
	}

private:
	STDataType* _a;
	size_t _capacity;
	size_t _top;
};

// 两个Stack实现队列
class MyQueue
{
public:
	//编译器默认生成MyQueue的构造函数调用了Stack的构造，完成了两个成员的初始化

private:
	Stack pushst;
	Stack popst;
};

int main()
{
	MyQueue mq;

	return 0;
}
```
# 三、析构函数
析构函数与构造函数功能相反，析构函数不是完成对对象本身的销毁(C++规定对象在销毁时会自动析构函数，完成对对象资源的清理释放工作)。功能类似于Destroy，而像Date没有Destroy，就是没有资源需要释放，所以Date不需要析构函数。
>**析构函数的特点：**
>1. 析构函数名是在类名前加上字符~：`~Stack()`
>2. 无参数无返回值
>3. 一个类只能有一个析构函数。若未显式定义，系统会自动生成默认的析构函数
>4. 对象生命周期结束时，系统会自动调用析构函数
>5. 跟构造函数类似，我们不写编译器自动生成的析构函数对内置类型成员不做处理，自定类型成员会调用他的析构函数
>6. 还需要注意的是我们显示写析构函数，对于自定义类型成员也会调用它的析构，也就是说**自定义类型成员无论什么情况都会调用析构函数**
>7. 如何类中没有申请资源时，析构函数可以不写，直接使用编译器生成的默认析构函数，如`Date`。如果默认生成的析构就可以用，也就不需要显示写析构，如`MyQueue`。但是有资源申请时，一定要自己写析构，否则会造成资源泄漏，如`Stack`

## 1、析构函数运用
```cpp
typedef int STDataType;
class Stack
{
public:
	Stack(int n = 4)
	{
		_a = (STDataType*)malloc(sizeof(STDataType) * n);
		if (nullptr == _a)
		{
			perror("malloc fail");
			return;
		}

		_capacity = n;
		_top = 0;
	}

	~Stack()
	{
		free(_a);
		_a == nullptr;
		_capacity = _top = 0;
	}

private:
	STDataType* _a;
	size_t _capacity;
	size_t _top;
};

// 两个Stack实现队列
class MyQueue
{
public:
	//编译器默认生成MyQueue的构造函数调用了Stack的构造，完成了两个成员的初始化
	//编译器默认生成MyQueue的析构函数调用了Stack的析构，释放的Stack内部的资源
private:

	//自定义类型，会调用自己的析构函数
	Stack pushst;
	Stack popst;
};

int main()
{
	MyQueue mq;

	return 0;
}
```
# 四、拷贝构造函数
一个构造函数的**第一个参数是自身类类型的引用，且任何额外的参数都有默认值**，则此构造函数也叫做拷贝构造函数，也就是说拷贝构造是一个特殊的构造函数
**拷贝构造函数的特点：**
>1. 拷贝构造函数是构造函数的一个重载
>2. 拷贝构造函数的第一个参数必须是类类型对象的引用，使用传值方式编译器会直接报错，因为会引发无穷递归调用。拷贝构造函数也可以多个参数，但是第一个参数必须是类类型对象的引用，后面的参数必须有缺省值。
>3. 自定义类型对象进行拷贝行为必须调用拷贝构造，所以这里自定义类型传值传参和传值返回都会调用拷贝构造完成。
>4. 若未显式定义拷贝构造，编译器会生成自动生成拷贝构造函数。自动生成的拷贝构造对内置类型成员变量会完成值拷贝/浅拷贝（一个字节一个字节的拷贝），对自定义类型成员变量会调用他的拷贝构造。
>5. (1)、像Date这样的类成员变量全是内置类型且没有指向什么资源，编译器自动生成的拷贝构造就可以完成需要的拷贝，所以不需要我们显示实现拷贝构造。(2)、像Stack这样的类，虽然也都是内置类型，但是_a指向了资源，编译器自动生成的值拷贝/浅拷贝不符合我们的需求，所以需要我们自己实现深拷贝。(3)、像MyQueue这样的类型内部主要是自定义类型Stack成员，编译器自动生成的拷贝构造会调用Stack的拷贝构造，也不需要我们显示实现MyQueue的拷贝构造。这里还有一个小技巧，如果一个类显示实现了析构并释放资源，那么他就需要显示写拷贝构造，否则就不需要。
>6. 传值返回会产生一个临时对象调用拷贝构造，传值引用返回，返回的是返回对象的别名（引用），没有产生拷贝。但是如果返回对象是函数的局部对象，函数结束就销毁了，这时的引用相当于一个野引用，类似一个野指针一样。传引用返回可以减少拷贝，但是一定要确保返回对象，在当前函数结束后还在，才能用引用返回。

![](图片/图片/QQ20251126-204315.png)

## 有误解代码：
### 1、无穷递归调用(引用的运用)
#### (1)无穷递归调用(无引用)
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

	//-----------------------------------------------
	//这里必须是引用，如果直接调用会导致无穷递归调用
	//d2(d1)
	Date(const Date d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}
	//-----------------------------------------------

private:
	int _year;
	int _month;
	int _day;
};

void Func1(Date d)
{
	cout << &d << endl;
	d.Print();
}

int main()
{
	Date d1(2025, 11, 16);
	d1.Print();

	Func1(d1);

	Date d2(d1);
	d2.Print();

	return 0;
}
```
#### (2)修改后的无穷递归调用(有引用)
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

	//-----------------------------------------------
	//这里必须是引用，如果直接调用会导致无穷递归调用
	//d2(d1)，加const是为了保护d不被修改
	Date(const Date& d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}
	//-----------------------------------------------

private:
	int _year;
	int _month;
	int _day;
};

//void Func1(Date d)
//这里把Date d--->Date& d是为了减少创建空间，
//调用自己提高效率
void Func1(const Date& d)
{
	cout << &d << endl;
	d.Print();
}

int main()
{
	Date d1(2025, 11, 16);
	d1.Print();

	Func1(d1);

	Date d2(d1);
	d2.Print();

	return 0;
}
```
![](图片/图片/QQ20251126-205009.png)

根据第第四条，拷贝构造函数与构造函数和析构函数不同，没有拷贝构造函数，编译器会自动生成拷贝构造函数，会自动调用内置类型。
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}
	
	//Date(const Date& d)
	//{
	//	_year = d._year;
	//	_month = d._month;
	//	_day = d._day;
	//}
private:
	int _year;
	int _month;
	int _day;
};

void Func1(Date& d)
{
	cout << &d << endl;
	d.Print();
}

int main()
{
	Date d1(2025, 11, 16);
	d1.Print();

	Func1(d1);

	Date d2(d1);
	d2.Print();

	return 0;
}
```

### 2、空间释放(浅拷贝与深拷贝的运用)
#### (1)同一个空间被释放两次(浅拷贝)
```cpp
#include<iostream>
using namespace std;

typedef int STDataType;
class Stack
{
public:
	Stack(int n = 4)
	{
		_a = (STDataType*)malloc(sizeof(STDataType) * n);
		if (nullptr == _a)
		{
			perror("malloc申请空间失败");
			return;
		}
		_capacity = n;
		_top = 0;
	}
	
	void Push(STDataType x)
	{
		if (_top == _capacity)
		{
			int newcapacity = _capacity * 2;
			STDataType* tmp = (STDataType*)realloc(_a, newcapacity *
				sizeof(STDataType));
			if (tmp == NULL)
			{
				perror("realloc fail");
				return;
			}
			_a = tmp;
			_capacity = newcapacity;
		}
		_a[_top++] = x;

	}

	//-----------------------------------------------
	~Stack()
	{
		cout << "~Stack()" << endl;
		free(_a);
		_a = nullptr;
		_top = _capacity = 0;
	}
	//-----------------------------------------------
private:
	STDataType* _a;
	size_t _capacity;
	size_t _top;
};

int main()
{
	Stack st1;
	st1.Push(1);
	st1.Push(2);
	
	//-----------------------------------------------
	// Stack不显示实现拷贝构造，用自动生成的拷贝构造完成浅拷贝
	// 会导致st1和st2里面的_a指针指向同一块资源，析构时会析构两次，程序崩溃
	Stack st2(st1);
	//-----------------------------------------------
	
	return 0;
}
```
**图示：**
![](图片/图片/QQ20251126-210509.png)
#### (2)修改正确后的代码(深拷贝)
```cpp
#include<iostream>
using namespace std;

typedef int STDataType;
class Stack
{
public:
	Stack(int n = 4)
	{
		_a = (STDataType*)malloc(sizeof(STDataType) * n);
		if (nullptr == _a)
		{
			perror("malloc申请空间失败");
			return;
		}
		_capacity = n;
		_top = 0;
	}

	// st2(st1)
	Stack(const Stack& st)
	{
		cout << "Stack(const Stack& st)" << endl;

		// 需要对_a指向资源创建同样大的资源再拷贝值
		_a = (STDataType*)malloc(sizeof(STDataType) * st._capacity);
		if (nullptr == _a)
		{
			perror("malloc申请空间失败!!!");
			return;
		}
		memcpy(_a, st._a, sizeof(STDataType) * st._top);
		_top = st._top;
		_capacity = st._capacity;
	}

	void Push(STDataType x)
	{
		if (_top == _capacity)
		{
			int newcapacity = _capacity * 2;
			STDataType* tmp = (STDataType*)realloc(_a, newcapacity *
				sizeof(STDataType));
			if (tmp == NULL)
			{
				perror("realloc fail");
				return;
			}
			_a = tmp;
			_capacity = newcapacity;
		}
		_a[_top++] = x;

	}

	~Stack()
	{
		cout << "~Stack()" << endl;
		free(_a);
		_a = nullptr;
		_top = _capacity = 0;
	}
private:
	STDataType* _a;
	size_t _capacity;
	size_t _top;
};

int main()
{
	Stack st1;
	st1.Push(1);
	st1.Push(2);

	// Stack不显示实现拷贝构造，用自动生成的拷贝构造完成浅拷贝
	// 会导致st1和st2里面的_a指针指向同一块资源，析构时会析构两次，程序崩溃
	Stack st2(st1);

	return 0;
}
```
![](图片/图片/QQ20251126-212106.png)
### 3、拷贝调用函数的运用
假如一个自定义函数有10000个数据，如果使用拷贝调用话，效率就特别低下。这时候就可以把`Stack st`改写成`const Stack& st`，st就是st1的另一个名称，这是传的就是st1本身。
```cpp
void func(const Stack& st)
{

}

int main()
{
	Stack st1;
	st1.Push(1);
	st1.Push(2);

	func(st1);
}
```
### 4、引用返回的运用
```cpp
//用引用可以减少拷贝的消耗
Stack& func2()
{
	//出来作用域st会销毁，防止放回空引用，用static改为静态
	static Stack st;
	
	return st;
}

int main()
{
	Stack ret = func2();
	
	return 0;
}
```
# 五、赋值运算符重载
## 1、运算符重载
>- 当运算符被用于类类型的对象时，C++语言允许我们通过运算符重载的形式指定新的含义。C++规定类类型对象使用运算符时，必须转换成调用对应运算符重载，若没有对应的运算符重载，则会编译报错。
>- 运算符重载是具有特殊名字的函数，他的名字是**由operator和后面要定义的运算符共同构成**。和其他函数一样，它也**具有其返回类型和参数列表以及函数体。**
>- 重载运算符函数的参数个数和该运算符作用的运算对象数量一样多。一元运算符有一个参数(常见的有++、--)，二元运算符有两个参数(常见的有+、-)，二元运算符的左侧运算对象传给第一个参数，右侧运算对象传给第二个参数。例如：`bool operator==(const Date& d1,const Date& d2)`和 `operator==(d1, d2);`
>- 如果**重载运算符函数是成员函数，则它的第一个运算对象默认传给隐式的this指针**，例如：`Date& operator(const Date& d)`
>- 运算符重载后，其优先级和结合性与对应的内置类型保持一致
>- 不能通过连接语法中没有的符号来创建新的操作符。例如：`operator@`
>- `.*  ::  sizeof  ?:  .`以上运算符不能重载
>- 重载操作符至少有一个类类型参数，不能通过运算符重载改变内置类型对象的含义。例如：`int operator+(int x, int y)`
>- 重载++运算符时，有前置++和后置++，运算符重载函数名都是`operator++`，无法很好的区分。C++规定，后置++重载时，增加一个int形参，跟前置++构成函数重载，方便区分。`Date& operator++(int) 与 Date& operator++()`
>- 重载`<<`和`>>`时，需要重载为全局函数，因为重载为成员函数，`this指针`默认抢占了第一个形参位置，第一个形参位置是左侧运算对象，调用时就变成了对象`<<cout`，不符合使用习惯和可读性。重载为全局函数把`ostream/istream放到第一个形参位置`就可以了，`第二个形参位置当类类型对象`。

### (1)重载未全局的面临对象访问私有成员变量的问题
有几种方法可以解决：
1. 成员公开
2. Date提供get函数
3. 友元函数
4. 重载未成员函数
#### 1.1成员公开
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

//这里把内置类型设置为公开，但是工作上不会这么写
//private:
	int _year;
	int _month;
	int _day;
};


//重载未全局的面临对象访问私有成员变量的问题
bool operator==(const Date& d1,const Date& d2)
{
	return d1._year == d2._year
		&& d1._month == d2._month
		&& d1._day == d2._day;
}


int main()
{
	Date d1(2025, 11, 26);
	Date d2(2025, 11, 27);

	//运算符重载函数可以显示调用
	operator==(d1, d2);

	//编译器会转变为operator==(d1, d2);
	d1 == d2;

	return 0;
}
```
#### 1.2友元函数
```cpp
#include<iostream>
using namespace std;

class Date
{
	//友元函数
	friend bool operator==(const Date& d1,const Date& d2);
	
public:
	//...
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2025, 11, 26);
	Date d2(2025, 11, 27);

	//运算符重载函数可以显示调用
	d1.operator==(d2);

	//编译器会转变为d1.operator==(d2);
	d1 == d2;

	return 0;
}
```
#### 1.3重载成员函数
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

	//重载未全局的面临对象访问私有成员变量的问题
	bool operator==(const Date& d)
	{
		return _year == d._year
			&& _month == d._month
			&& _day == d._day;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2025, 11, 26);
	Date d2(2025, 11, 27);

	//运算符重载函数可以显示调用
	d1.operator==(d2);

	//编译器会转变为d1.operator==(d2);
	d1 == d2;

	return 0;
}
```
## (2)赋值运算符重载
- 赋值运算符重载用于两个已经存在的对象直接拷贝赋值
- 拷贝构造用于一个对象拷贝初始化给另一个要创建的对象
```cpp
int main()
{
	Date d1(2025, 11, 26);
	Date d2(2025, 11, 27);

	//赋值重载拷贝
	d2 = d1;

	//拷贝构造
	Date d3(d2);
	Date d4 = d3;

	return 0;
}
```
>**赋值运算符重载的特点：**
>1. 赋值运算符重载是一个运算符重载，规定必须重载为成员函数。赋值运算重载的参数建议写成const当前类类型引用，否则会传值传参会有拷贝
>2. 有返回值，且建议写成当前类类型引用，引用返回可以提高效率，有返回值目的是为了支持连续赋值场景。
>3. 没有显式实现时，编译器会自动生成一个默认赋值运算符重载，默认赋值运算符重载行为跟默认拷贝构造函数类似，对内置类型成员变量会完成值拷贝/浅拷贝，对自定义类型成员变量会调用他的赋值重载函数。
>4. **总结**：如果显示了析构释放资源，就需要实现拷贝构造和赋值重载。没有显示析构就不需要实现拷贝构造和赋值重载。

```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

	// 传引用返回减少拷贝
	// d1 = d2
	Date& operator=(const Date& d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;

		// d1=d2表达式的返回对象应该为d1，也就是*this
		return *this;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2025, 11, 26);
	//拷贝构造
	Date d2 = d1;

	
	Date d3(2025, 11, 27);
	//拷贝运算符重载
	d1 = d3;

	//拷贝构造
	Date d4 = d3;

	return 0;
}
```
### (3)连续赋值
```cpp
Date& operator=(const Date& d)
{
	_year = d._year;
	_month = d._month;
	_day = d._day;

	// d1=d2表达式的返回对象应该为d1，也就是*this
	return *this;
}
```

```cpp
int main()
{
	Date d1(2025, 11, 26);
	//拷贝构造
	Date d2 = d1;

	
	Date d3(2025, 11, 27);
	//拷贝运算符重载
	d1 = d3;

	//拷贝构造
	Date d4 = d3;

	//连续赋值
	d1 = d2 = d3;

	return 0;
}
```
# 六、构造函数与运算符重载总结
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	//构造函数
	Date(int year = 1900, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

	//拷贝构造函数
	Date(const Date& d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}

	//运算符重载
	Date& operator=(const Date& d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
		
		return *this;
	}

private:
	int _year;
	int _month;
	int _day;
};

void Func1(Date& d)
{
	cout << &d << endl;
	d.Print();
}

void Test01()
{
	//构造函数
	Date d1(2020, 11, 28);
	d1.Print();

	Func1(d1);

	//拷贝构造函数
	Date d2 = d1;
	d2.Print();

	//构造函数
	Date d3(2007, 6, 18);

	//赋值运算符重载
	d1 = d3;
	d1.Print();

	//赋值运算符重载
	d2 = d1 = d3;
}

int main()
{
	Test01();

	return 0;
}
```
# 七、日期实现
## (1)整个代码
```cpp
/* Date.h */

#pragma once
#include<assert.h>
#include<iostream>
using namespace std;

class Date
{
	//友元函数(可将流放入this位)
	friend ostream& operator<<(ostream& out, const Date& d);
	friend istream& operator>>(istream& in, Date& d);

public:
	//构造函数(可省略创建Init)
	Date(int year = 1990, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;

		//当日期不正确时，报错并打印出非法日期
		if (!CheckDate())
		{
			cout << "非法日期";
			Print();
		}
	}

	void Print()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}

	//最常调用的函数，应放到类里面实现。编译器会自动加上内联函数(inline)提高效率
	inline int GetMonthDay(int year, int month)
	{
		//非法月份
		assert(month > 0 && month < 13);

		//放回每个月的总天数(用数组实现，也要判断年份是否为闰年时)
		static int MontDayArray[13] = { -1, 31, 28, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30 };
		if ((month == 2 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)))
		{
			return 29;
		}
		return MontDayArray[month];
	}

	//判断是否非法日期
	 bool CheckDate();
	
	 //用运算符重载来比较两日期
	 //在类中，this指针指向第一类，第二类在( )中写入
	 bool operator<(const Date& d);
	 bool operator<=(const Date& d);
	 bool operator>(const Date& d);
	 bool operator>=(const Date& d);
	 bool operator==(const Date& d);
	 bool operator!=(const Date& d);

	 //运用引用时，减少拷贝，提高效率
	 Date& operator+=(int day);
	 Date operator+(int day);

	 Date& operator-=(int day);
	 Date operator-(int day);

	 //前置++()中为空
	 //后置++需要()中加上int
	 Date operator++(int);
	 Date& operator++();

	 Date operator--(int);
	 Date& operator--();

	 //两日期相减，返回的是整形
	 int operator-(const Date& d);

	 //this接收d、io流只能在第二位
	 //ostream& operator<<(ostream& out);

private:
	//内置类型没有申请空间，不需要析构函数
	int _year;
	int _month;
	int _day;
};

//用全局，可将this做为io流，d在第二位
ostream& operator<<(ostream& out, const Date& d);

istream& operator>>(istream& in, Date& d);
```

```cpp
/* Date.cpp */

#define _CRT_SECURE_NO_WARNINGS
#include"Date.h"

//类外定义，需要运用到命名空间的知识
bool Date::CheckDate()
{
	if (_month < 1 || _month > 12
		|| _day < 1 || _day > GetMonthDay(_year, _month))
	{
		return false;
	}
	else
	{
		return true;
	}
}

Date& Date::operator+=(int day)
{
	//实现日期改变
	if (day < 0)
	{
		return *this -= (-day);
	}

	_day += day;
	while (_day > GetMonthDay(_year, _month))
	{
		_day -= GetMonthDay(_year, _month);
		_month++;

		if (_month == 13)
		{
			_year++;
			_month = 1;
		}
	}

	return *this;
}

Date Date::operator+(int day)
{
	Date tmp = *this;
	tmp += day;
	
	return tmp;
}

Date& Date::operator-=(int day)
{
	if (day < 0)
	{
		return *this += (-day);
	}

	_day -= day;
	while(_day <= 0)
	{
		_month--;
		if (_month == 0)
		{
			_year--;
			_month = 12;
		}
		_day += GetMonthDay(_year, _month);
	}
	
	return *this;
}

Date Date::operator-(int day)
{
	Date tmp = *this;
	tmp -= day;

	return tmp;
}

//Date& Date::operator-=(int day)
//{
//	*this = *this - day;
//
//	return *this;
//}
//
//Date Date::operator-(int day)
//{
//	Date tmp = *this;
//	
//	tmp._day -= day;
//	while (tmp._day <= 0)
//	{
//		tmp._month--;
//		if (tmp._month == 0)
//		{
//			tmp._year--;
//			tmp._month = 12;
//		}
//		tmp._day += GetMonthDay(tmp._year, tmp._month);
//	}
//
//	return tmp;
//}

//d2 < d1
bool Date::operator<(const Date& d)
{
	if (_year < d._year)
	{
		return true;
	}
	else if (_year == d._year)
	{
		if (_month < d._month)
		{
			return true;
		}
		else if (_month == d._month)
		{
			return _day < d._day;
		}
	}

	return false;
}

//d2 <= d1
bool Date::operator<=(const Date& d)
{
	return *this < d || *this == d;
}

//d2 > d1
bool Date::operator>(const Date& d)
{
	return !(*this <= d);
}

//d2 >= d1
bool Date::operator>=(const Date& d)
{
	return !(*this < d);
}

//d2 == d1
bool Date::operator==(const Date& d)
{
	return _year == d._year
		&& _month == d._month
		&& _day == d._day;
}

//d2 != d1
bool Date::operator!=(const Date& d)
{
	return !(*this == d);
}

Date Date::operator++(int)
{
	Date tmp = *this;
	*this += 1;
	return tmp;
}

Date& Date::operator++()
{
	*this += 1;
	return *this;
}

Date Date::operator--(int)
{
	Date tmp = *this;
	*this -= 1;
	return tmp;
}

Date& Date::operator--()
{
	*this -= 1;
	return *this;
}

// d1 - d2
int Date::operator-(const Date& d)
{
	int flag = 1;
	Date max = *this;
	Date min = d;
	if (*this < d)
	{
		max = d;
		min = *this;
		flag = -1;
	}

	int n = 0;
	while (min != max)
	{
		++min;
		++n;
	}

	return n * flag;
}


//ostream& Date::operator<<(ostream& out)
//{
//	out << _year << "年" << _month << "月" << _day << "日" << endl;
//	return out;
//}

ostream& operator<<(ostream& out, const Date& d)
{
	out << d._year << "年" << d._month << "月" << d._day << "日" << endl;

	return out;
}

istream& operator>>(istream& in, Date& d)
{
	cout << "请输入年月日:>";
	in >> d._year >> d._month >> d._day;

	return in;
}
```

```cpp
/* test.cpp */

#define _CRT_SECURE_NO_WARNINGS
#include"Date.h"

void Test01()
{
	Date d1(2025, 11, 28);
	d1.Print();

	Date d2 = d1 - 100;
	d2.Print();
}

void Test02()
{
	Date d1(2024, 7, 13);
	Date ret1 = d1++;
	ret1.Print();
	d1.Print();

	Date d2(2024, 7, 13);
	Date ret2 = ++d2;
	ret2.Print();
	d2.Print();
}

void Test03()
{
	Date d1(2024, 7, 12);
	d1 += -100;
	d1.Print();

	d1 -= -100;
	d1.Print();
}

void Test04()
{
	Date d1(2034, 10, 1);
	Date d2(2024, 6, 31);

	cout << d1 - d2 << endl;
}

void Test05()
{
	Date d1(2025, 11, 27);
	Date d2(2025, 11, 28);
	//倒反天罡(在成员函数中，this指针是d1，而out却在第二个中)
	//d1 << cout;
	//d1.operator<<(cout);

	//返回值接收流，可以输出多个
	cout << d1 << d2;
}

void Test06()
{
	Date d1;
	Date d2;

	cin >> d1 >> d2;
	cout << d1 << d2;

	cout << d1 - d2 << endl;
}

int main()
{
	Test06();

	return 0;
}
```
## (2)超级拆解日期实现
### 1.1构造函数
```cpp
//构造函数(可省略创建Init)
Date(int year = 1990, int month = 1, int day = 1)
{
	_year = year;
	_month = month;
	_day = day;

	//当日期不正确时，报错并打印出非法日期
	if (!CheckDate())
	{
		cout << "非法日期";
		Print();
	}
}

void Test01()
{
	Date d1(2025, 11, 28);
	d1.Print();
}
```
### 1.2析构函数
**内置类型没有申请空间，不需要自己写析构函数，编译器会自己生成**
```cpp
private:
	//内置类型没有申请空间，不需要析构函数
	int _year;
	int _month;
	int _day;
```
### 1.3二元运算符重载
```cpp
class Date()
{
	//运用引用时，减少拷贝，提高效率
	Date& operator+=(int day);
	Date operator+(int day);
	
	Date& operator-=(int day);
	Date operator-(int day);
}

/* Date.cpp */
Date& Date::operator+=(int day)
{
	//实现日期改变
	if (day < 0)
	{
		return *this -= (-day);
	}

	_day += day;
	while (_day > GetMonthDay(_year, _month))
	{
		_day -= GetMonthDay(_year, _month);
		_month++;

		if (_month == 13)
		{
			_year++;
			_month = 1;
		}
	}

	return *this;
}

Date Date::operator+(int day)
{
	Date tmp = *this;
	tmp += day;
	
	return tmp;
}

Date& Date::operator-=(int day)
{
	if (day < 0)
	{
		return *this += (-day);
	}

	_day -= day;
	while(_day <= 0)
	{
		_month--;
		if (_month == 0)
		{
			_year--;
			_month = 12;
		}
		_day += GetMonthDay(_year, _month);
	}
	
	return *this;
}

Date Date::operator-(int day)
{
	Date tmp = *this;
	tmp -= day;

	return tmp;
}
```
### 1.4二元运算符重载(比较)
```cpp
class Date()
{
	//用运算符重载来比较两日期
	//在类中，this指针指向第一类，第二类在( )中写入
	bool operator<(const Date& d);
	bool operator<=(const Date& d);
	bool operator>(const Date& d);
	bool operator>=(const Date& d);
	bool operator==(const Date& d);
	bool operator!=(const Date& d);
}

//d2 < d1
bool Date::operator<(const Date& d)
{
	if (_year < d._year)
	{
		return true;
	}
	else if (_year == d._year)
	{
		if (_month < d._month)
		{
			return true;
		}
		else if (_month == d._month)
		{
			return _day < d._day;
		}
	}

	return false;
}

//d2 <= d1
bool Date::operator<=(const Date& d)
{
	return *this < d || *this == d;
}

//d2 > d1
bool Date::operator>(const Date& d)
{
	return !(*this <= d);
}

//d2 >= d1
bool Date::operator>=(const Date& d)
{
	return !(*this < d);
}

//d2 == d1
bool Date::operator==(const Date& d)
{
	return _year == d._year
		&& _month == d._month
		&& _day == d._day;
}

//d2 != d1
bool Date::operator!=(const Date& d)
{
	return !(*this == d);
}
```
### 1.5一元运算符重载
```cpp
class Date()
{
	//前置++()中为空
	//后置++需要()中加上int
	Date operator++(int);
	Date& operator++();
	
	Date operator--(int);
	Date& operator--();
}

Date Date::operator++(int)
{
	Date tmp = *this;
	*this += 1;
	return tmp;
}

Date& Date::operator++()
{
	*this += 1;
	return *this;
}

Date Date::operator--(int)
{
	Date tmp = *this;
	*this -= 1;
	return tmp;
}

Date& Date::operator--()
{
	*this -= 1;
	return *this;
}
```
### 1.6日期相减
```cpp
class Date()
{
	//两日期相减，返回的是整形
	int operator-(const Date& d);
}

// d1 - d2
int Date::operator-(const Date& d)
{
	int flag = 1;
	Date max = *this;
	Date min = d;
	if (*this < d)
	{
		max = d;
		min = *this;
		flag = -1;
	}

	int n = 0;
	while (min != max)
	{
		++min;
		++n;
	}

	return n * flag;
}
```
### 1.7流的运用
```cpp
class Date()
{
	//友元函数(可将流放入this位)
	friend ostream& operator<<(ostream& out, const Date& d);
	friend istream& operator>>(istream& in, Date& d);
}

ostream& operator<<(ostream& out, const Date& d)
{
	out << d._year << "年" << d._month << "月" << d._day << "日" << endl;

	return out;
}

istream& operator>>(istream& in, Date& d)
{
	cout << "请输入年月日:>";
	in >> d._year >> d._month >> d._day;

	return in;
}
```

# 八、取地址运算符重载
## 1、const成员函数
>- 将const修饰的成员函数称之为const成员函数，const修饰成员函数放到成员函数参数列表的后面
>- const实际修饰成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。const修饰Date类的Print成员函数，Print隐含的this指针由`Date* const this`变为`const Date* const this`

```cpp
class Date
{
	//这里的Print也要进行权限放大
	void Print()const
	{
	cout << _year << "/" << _month << "/" << _day << endl;
	}
}

void Test01()
{
	//这里用const将d1的权限放大，不能对d1进行打印
	const Date d1(2025, 11, 30);
	d1.Print();
	
	//const的Print照样可以打印不加const的d2
	Date d2(2025, 12, 1);
	d2.Print();

}
```
## 2、取地址运算符重载
取地址运算符重载分为普通地址运算符和const取地址运算符重载，一般这两个函数编译器自动生成的就可以够我们使用，不需要去显示实现。除非有些很特殊的场景，比如我们不想让别人取到当前类对象的地址，就可以自己实现一份，胡乱返回一个地址
```cpp
#include<iostream>
using namespace std;

class Date
{
public:
	Date(int year, int month, int day)
		:_year(year)
		,_month(month)
		,_day(day)
	{}

	//Date const this;
	Date* operator&()
	{
		//可以是自己定义的值，但是要修改成定义类型

		return this;
		//return nullptr;
		//return (Date*)2256FF00X30
	}

	//const Date const this;
	const Date* operator&() const
	{
		//可以是自己定义的值，但是要修改成定义类型

		return this;
		//return nullptr;
		//return (Date*)2256FF00X46   
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{

	return 0;
}
```