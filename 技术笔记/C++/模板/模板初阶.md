# 一、函数模板：类型无关的通用编程

## 1.1 函数模板的定义与基本用法
函数模板是 C++ 实现泛型编程的核心工具，它允许我们定义一个通用函数，而不必为每种可能的数据类型重复编写代码。其基本格式如下：
```
template<class T1, class T2, ...>
返回值类型 函数名(参数列表) {}
```

交换函数模板：
```cpp
template<class T>
void Swap(T& x, T& y)
{
    T tmp = x;
    x = y;
    y = tmp;
}
```
这个模板可以用于交换任何类型的变量，无论是`int`、`double`还是自定义类型，大大提高了代码的复用性。
## 1.2 函数模板的实例化
当使用不同类型的参数调用模板函数时，编译器会根据参数类型生成相应的具体函数，这个过程称为实例化，分为两种方式：

### （1）隐式实例化(编译器根据实参推导模板参数)
```cpp
template<class T>
T Add(const T& x, const T& y)
{
	return x + y;
}

int main()
{
	int a1 = 10, a2 = 20;
	double d1 = 10.1, d2 = 20.2;
	Add(a1, a2);  //推导出T为int
	Add(d1, d2);  //推导出T为double
	
	/*该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T，注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅
Add(a1, d1);
*/
// 此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化编译器无法确定此处到底该将T确定为int 或者 double类型而报错
	
	// 推导实例化
	cout << Add(a1, (int)d1) << endl;
	cout << Add((double)a1, d1) << endl;

	return 0;
}
```
需要注意的是，编译器不会自动进行类型转换，因此`Add(a, c)`这样的调用会失败，需要手动转换类型或使用显式实例化。
### （2）显示实例化(在函数名后的<>中指定模板参数的实际类型)
手动指定模板参数类型：
```cpp
int main()
{
    int a = 10;
    double c = 1.5;
    Add<int>(a, c);    // 显式指定T为int，将c隐式转换为int
    Add<double>(a, c); // 显式指定T为double，将a隐式转换为double
    return 0;
}
```

```cpp
template<class T>
T Add(const T& x, const T& y)
{
	return x + y;
}

int main()
{
	int a1 = 10, a2 = 20;
	double d1 = 10.1, d2 = 20.2;
	Add(a1, a2);
	Add(d1, d2);
	
	// 显示实例化
	cout << Add<int>(a1, d1) << endl;
	cout << Add<double>(a1, d1) << endl;

	cout << Add(a1, d1) << endl;

	double* p1 = func1<double>(10);

	return 0;
}
```
## 1.3 模板参数的匹配原则
### 原则1
**非模板函数与模板函数共存**：同名的非模板函数可以和函数模板同时存在，编译器会优先调用非模板函数
 ```cpp
 // 专门处理int的加法函数
int Add(int left, int right)
{
	return left + right;
}
// 通用加法函数
template<class T>
T Add(T left, T right)
{
	return left + right;
}
void Test()
{
	Add(1, 2); // 与非模板函数匹配，编译器不需要特化
	Add<int>(1, 2); // 调用编译器特化的Add版本
}
 ```
### 原则2
**更优匹配原则**：如果模板能生成更匹配的版本，则选择模板
```cpp
// 专门处理int的加法函数
int Add(int left, int right)
{
	return left + right;
}
// 通用加法函数
template<class T1, class T2>
T1 Add(T1 left, T2 right)
{
	return left + right;
}
void Test()
{
	Add(1, 2); // 与非函数模板类型完全匹配，不需要函数模板实例化
	Add(1, 2.0); // 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数
}
```
# 二、类模板：通用数据结构的实现基础
## 2.1 类模板的定义格式
```cpp
template<class T1, class T2, ..., class Tn>
class 类模板名
{
	// 类内成员定义
};
```
## 2.2 类模板
类模板用于创建通用的类，特别适合实现数据结构（如栈、队列、链表等）：
```cpp
template<class T>
class Stack
{
public:
	Stack(int n = 4)
		:_arr(new T[n])
		,_size(0)
		,_capacity(n)
	{ }

	~Stack()
	{
		delete[] _arr;
		_arr = nullptr;
		_size = _capacity = 0;
	}

	void Push(const T& x);

	void func(const T& x)
	{
		++x;
	}

private:
	T* _arr;
	int _size;
	int _capacity;
};

// 模版不建议声明和定义分离到两个文件.h 和.cpp会出现链接错误
template<class T>
void Stack<T>::Push(const T& x)
{
	if (_size == _capacity)
	{
		//C++中栈的内存申请方式
		T* tmp = new T[_capacity * 2];
		memcpy(tmp, _arr, sizeof(T) * _size);
		delete[] _arr;

		_arr = tmp;
		_capacity *= 2;
	}

	_arr[_size++] = x;
}

int main()
{
	Stack<int> st1;
	st1.Push(1);
	st1.Push(1);
	st1.Push(1);
	st1.Push(1);

	Stack<double> st2;
	st2.Push(1.1);
	st2.Push(1.1);
	st2.Push(1.1);
	st2.Push(1.1);

	return 0;
}
```