>**前言**
>在之前写过关于模板的初阶用法，也就是最简单的写法，编译器直接问自行判断该模板的类型。这篇文章将要讲解模板的进阶用法

# 一、非类型模板参数
模板参数分：
1. 类类型形参
	- 出现在模板参数列表中，跟在class或者typename这两类的参数类型名称
2. 非类型形参
	- 一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将参数当成常量来使用
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<assert.h>
using namespace std;

// 1. 浮点数、类对象以及字符串是不允许作为非类型模板参数的。
// 2. 非类型的模板参数必须在编译期就能确认结果。
namespace yuuki
{
	// 定义一个模板类型的静态数组
	template<class T, size_t N = 10>
	class array
	{
	public:
		T& operator[](size_t index)
		{
			assert(index < N);
			return _array[index];
		}

		const T& operator[](size_t index) const
		{
			assert(index < N);
			return _array[index];
		}

		size_t size(){return _size;}

		bool empty(){return _size == 0;}

	private:
		T* _array[N]; // 用非类型模板确定大小
		size_t _size; // 静态数组的大小
	};
}
```
>**注意：**
>1. 浮点数、类对象以及字符串是不允许作为非类型模板参数的
>2. 非类型的模板参数必须在编译期就能确认结果

# 二、模板的特化
## 2.1概念
通常使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结果，需要特殊处理
```cpp
// 函数模板 -- 参数匹配
template<class T>
bool Less(T left, T right)
{
	return left < right;
}
int main()
{
	cout << Less(1, 2) << endl; // 可以比较，结果正确

	Date d1(2022, 7, 7);
	Date d2(2022, 7, 8);
	cout << Less(d1, d2) << endl; // 可以比较，结果正确

	Date* p1 = &d1;
	Date* p2 = &d2;
	cout << Less(p1, p2) << endl; // 可以比较，结果错误

	return 0;
}
```
my_less在大多数情况下都正常比较，但在上述场景下错误。是因为p1、p2分别指向d1、d2指针的地址。此时，就**需要对模板进行特化(即：在原模版类的基础上，针对特殊类型所进行特殊化的实现方式***。模板特化中分为**函数模板特化**与**类模板特化**)
## 2.2函数模板特化
>函数模板特化步骤：
>1. 必须要有一个基础的函数模板
>2. 关键字template后面接<>
>3. 函数名跟一对尖括号，加括号(需指定特化的类型)
>4. 函数形参表：必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误
```cpp
template<class T>
bool my_less(T left, T right)
{
	return left < right;
}

// 模板特化
template<>
bool my_less<Date*>(Date* left, Date* right)
{
	return *left < *right;
}

//-----------------------------------------------------
// 正常来说都要加上const和&
template<class T>
bool my_less(const T& left, const T& right)
{
	return left < right;
}

// 普通类型的形参有const，就要特化就要成下面
template<> // const要修饰left而非*，所以要放在*右边，不然报错
bool my_less<Date*>(Date* const & left, Date* const & right)
{
	return *left < *right;
}
//-----------------------------------------------------


// 如果是const类型，就要特化就要成下面
template<> // const要修饰left而非*，所以要放在*右边，不然报错
bool my_less<const Date*>(const Date* const& left, const Date* const& right)
{
	return *left < *right;
}

int main()
{
	cout << my_less(1, 2) << endl; // 1
	
	Date d1(2022, 7, 7);
	Date d2(2022, 7, 8);
	cout << my_less(d1, d2) << endl; // 可以比较，结果正确

	Date* p1 = &d1;
	Date* p2 = &d2;
	cout << my_less(p1, p2) << endl; // 可以比较，结果错误

	const Date* p3 = &d1;
	const Date* p4 = &d2;
	cout << my_less(p3, p4) << endl; // 可以比较，结果错误

	return 0;
}
```
**注意：一般情况下如果函数模板遇到不能处理或处理有误的类型，为了实现简单通常都是将该函数直接给出**
```cpp
bool my_less(Date* left, Date* right)
{
	return *left < *right;
}
```
该种实现简单明了，代码的可读性高，容易书写，因为对于一些参数类型复杂的函数模板，特化
时特别给出，因此函数模板不建议特化。
## 2.3类模板特化
### 2.3.1全特化
全特化：是将模板参数列表中所有的参数都确定化
```cpp
// 类模板全特化
template<class T1, class T2>
class Data
{
public:
	Data() { cout << "Data<T1, T2>" << endl;}
};

template<>
class Data<int, char> // 这里指定了类型
{
public:
	Data() { cout << "Data<int, char>" << endl;}
};

int main()
{
	Data<int, int> d1;	// Data<T1, T2>
	Data<int, char> d2; // Data<int, char>
	cout << endl;

	return 0;
}
```
### 2.3.2偏特化
偏特化：任何针对模板参数进一步进行条件限制
```cpp
// 类模板半特化
// 部分特化(将模板参数类列表中的一部分参数特化)
template<class T>
class Data<T&, int>
{
public:
	Data() { cout << "Data<T&, int>" << endl;}
};

// 两个参数偏特化为指针类型
template<class T1, class T2>
class Data<T1*, T2*>
{
public:
	Data() { cout << "Data<T1*, T2*>" << endl; }
};

// 两个参数偏特化为引用类型
template<class T1, class T2>
class Data<T1*, T2&>
{
public:
	Data() { cout << "Data<T1*, T2&>" << endl; }
};

int main()
{
	Data<char, int> p1;		// Data<T1, T2>
	Data<double, int> p2;	// Data<T1, T2>
	cout << endl;

	Data<int*, int*> p3;		// Data<T1*, T2*>
	Data<double*, short*> p4;	// Data<T1*, T2*>
	Data<int*, int&> p5;		// Data<T1*, T2&>
	cout << endl;

	return 0;
}
```
### 2.3.3类模板特化应用实例
```cpp
#include<vector>
#include<algorithm>
template<class T>
struct Less
{
	bool operator()(const T& x, const T& y) const
	{
		return x < y;
	}
};

int main()
{
	Date d1(2022, 7, 7);
	Date d2(2022, 7, 6);
	Date d3(2022, 7, 8);
	
	vector<Date> v1;
	v1.push_back(d1);
	v1.push_back(d2);
	v1.push_back(d3);
	// 可以直接排序，结果是日期升序
	sort(v1.begin(), v1.end(), Less<Date>());
	
	vector<Date*> v2;
	v2.push_back(&d1);
	v2.push_back(&d2);
	v2.push_back(&d3);
	// 可以直接排序，结果错误日期还不是升序，而v2中放的地址是升序
	// 此处需要在排序过程中，让sort比较v2中存放地址指向的日期对象
	// 但是走Less模板，sort在排序时实际比较的是v2中指针的地址，因此无法达到预期
	sort(v2.begin(), v2.end(), Less<Date*>());
	return 0;
}
```
通过观察上述程序的结果发现，对于日期对象可以直接排序，并且结果是正确的。但是如果待排序元素是指针，结果就不一定正确。因为：sort最终按照Less模板中方式比较，所以只会比较指针，而不是比较指针指向空间中内容，此时可以使用类版本特化来处理上述问题：
```cpp
// 对Less类模板按照指针方式特化
template<>
struct Less<Date*>
{
	bool operator()(Date* x, Date* y) const
	{
	return *x < *y;
	}
};
```
特化之后，在运行上述代码，就可以得到正确的结果
# 三、模板分离编译

## 3.1概念
>一个程序（项目）由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件链接起来形成单一的可执行文件的过程称为分离编译模式。
## 3.2模板的分离编译
假如有以下场景，模板的声明与定义分离开，在头文件中进行声明，源文件中完成定义：
```cpp
// a.h
template<class T>
T Add(const T& left, const T& right);

// a.cpp
template<class T>
T Add(const T& legt, const T& right)
{
	return left + right;
}

// main.cpp
#include"a.h"
int main()
{
	Add(1, 2);
	Add(1.0, 2.0);
	
	return 0;
}
```
 原理：
 ![](图片/模板进阶.png)
## 3.3解决方法
-  将声明和定义放到一个文件 `"xxx.hpp" `里面或者`xxx.h`其实也是可以的。推荐使用这种。
-  模板定义的位置显式实例化。这种方法不实用，不推荐使用。
# 四、模板总结
 > 【优点】
 > 1. 模板复用了代码，节省资源，更快的迭代开发，C++的标准模板库(STL)因此而产生
 > 2. 增强了代码的灵活性
 > 
 > 【缺陷】
 >  1. 模板会导致代码膨胀问题，也会导致编译时间变长
 >  2. 出现模板编译错误时，错误信息非常凌乱，不易定位错误