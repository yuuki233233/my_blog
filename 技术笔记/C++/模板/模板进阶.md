>**前言**
>在之前写过关于模板的初阶用法，也就是最简单的写法，编译器直接问自行判断该模板的类型。这篇文章将要讲解模板的进阶用法

# 一、非类型模板参数
模板参数分：
1. 类类型形参
	- 出现在模板参数列表中，跟在class或者typename这两类的参数类型名称
2. 非类型形参
	- 一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将参数当成常量来使用
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<assert.h>
using namespace std;

// 1. 浮点数、类对象以及字符串是不允许作为非类型模板参数的。
// 2. 非类型的模板参数必须在编译期就能确认结果。
namespace yuuki
{
	// 定义一个模板类型的静态数组
	template<class T, size_t N = 10>
	class array
	{
	public:
		T& operator[](size_t index)
		{
			assert(index < N);
			return _array[index];
		}

		const T& operator[](size_t index) const
		{
			assert(index < N);
			return _array[index];
		}

		size_t size(){return _size;}

		bool empty(){return _size == 0;}

	private:
		T* _array[N]; // 用非类型模板确定大小
		size_t _size; // 静态数组的大小
	};
}
```
>**注意：**
>1. 浮点数、类对象以及字符串是不允许作为非类型模板参数的
>2. 非类型的模板参数必须在编译期就能确认结果

# 二、模板的特化
## 2.1概念
通常使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结果，需要特殊处理
```cpp
// 函数模板 -- 参数匹配
template<class T>
bool Less(T left, T right)
{
	return left < right;
}
int main()
{
	cout << Less(1, 2) << endl; // 可以比较，结果正确

	Date d1(2022, 7, 7);
	Date d2(2022, 7, 8);
	cout << Less(d1, d2) << endl; // 可以比较，结果正确

	Date* p1 = &d1;
	Date* p2 = &d2;
	cout << Less(p1, p2) << endl; // 可以比较，结果错误

	return 0;
}
```
my_less在大多数情况下都正常比较，但在上述场景下错误。是因为p1、p2分别指向d1、d2指针的地址。此时，就**需要对模板进行特化(即：在原模版类的基础上，针对特殊类型所进行特殊化的实现方式***。模板特化中分为**函数模板特化**与**类模板特化**)
## 2.2函数模板特化
>函数模板特化步骤：
>1. 必须要有一个基础的函数模板
>2. 关键字template后面接<>
>3. 函数名跟一对尖括号，加括号(需指定特化的类型)
>4. 函数形参表：必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误
```cpp
template<class T>
bool my_less(T left, T right)
{
	return left < right;
}

// 模板特化
template<>
bool my_less<Date*>(Date* left, Date* right)
{
	return *left < *right;
}

//-----------------------------------------------------
// 正常来说都要加上const和&
template<class T>
bool my_less(const T& left, const T& right)
{
	return left < right;
}

// 普通类型的形参有const，就要特化就要成下面
template<> // const要修饰left而非*，所以要放在*右边，不然报错
bool my_less<Date*>(Date* const & left, Date* const & right)
{
	return *left < *right;
}
//-----------------------------------------------------


// 如果是const类型，就要特化就要成下面
template<> // const要修饰left而非*，所以要放在*右边，不然报错
bool my_less<const Date*>(const Date* const& left, const Date* const& right)
{
	return *left < *right;
}

int main()
{
	cout << my_less(1, 2) << endl; // 1
	
	Date d1(2022, 7, 7);
	Date d2(2022, 7, 8);
	cout << my_less(d1, d2) << endl; // 可以比较，结果正确

	Date* p1 = &d1;
	Date* p2 = &d2;
	cout << my_less(p1, p2) << endl; // 可以比较，结果错误

	const Date* p3 = &d1;
	const Date* p4 = &d2;
	cout << my_less(p3, p4) << endl; // 可以比较，结果错误

	return 0;
}
```
**注意：一般情况下如果函数模板遇到不能处理或处理有误的类型，为了实现简单通常都是将该函数直接给出**
```cpp
bool my_less(Date* left, Date* right)
{
	return *left < *right;
}
```
该种实现简单明了，代码的可读性高，容易书写，因为对于一些参数类型复杂的函数模板，特化
时特别给出，因此函数模板不建议特化。
## 2.3类模板特化
### 2.3.1全特化
全特化：是将模板参数列表中所有的参数都确定化
```cpp
// 类模板全特化
template<class T1, class T2>
class Data
{
public:
	Data() { cout << "Data<T1, T2>" << endl;}
};

template<>
class Data<int, char> // 这里指定了类型
{
public:
	Data() { cout << "Data<int, char>" << endl;}
};

int main()
{
	Data<int, int> d1;	// Data<T1, T2>
	Data<int, char> d2; // Data<int, char>
	cout << endl;

	return 0;
}
```
### 2.3.2偏特化
偏特化：任何针对模板参数进一步进行条件限制
```cpp
// 类模板半特化
// 部分特化(将模板参数类列表中的一部分参数特化)
template<class T>
class Data<T&, int>
{
public:
	Data() { cout << "Data<T&, int>" << endl;}
};

// 两个参数偏特化为指针类型
template<class T1, class T2>
class Data<T1*, T2*>
{
public:
	Data() { cout << "Data<T1*, T2*>" << endl; }
};

// 两个参数偏特化为引用类型
template<class T1, class T2>
class Data<T1*, T2&>
{
public:
	Data() { cout << "Data<T1*, T2&>" << endl; }
};

int main()
{
	Data<char, int> p1;		// Data<T1, T2>
	Data<double, int> p2;	// Data<T1, T2>
	cout << endl;

	Data<int*, int*> p3;		// Data<T1*, T2*>
	Data<double*, short*> p4;	// Data<T1*, T2*>
	Data<int*, int&> p5;		// Data<T1*, T2&>
	cout << endl;

	return 0;
}
```
### 2.3.3类模板特化应用实例
```cpp

```
# 三、模板分离编译
## 3.1概念
## 3.2模板的分离编译
## 3.3解决方法
# 四、模板总结