# 用顺序表与递归实现通讯录：从设计到代码的完整指南

通讯录是我们日常常用的工具，它本质上是一个存储联系人信息的集合。本文将带你用**顺序表**存储联系人数据，并结合**递归函数**实现联系人的查询、遍历等功能，最终完成一个简易但功能完整的通讯录。

## 一、需求分析：通讯录需要哪些功能？

一个基础的通讯录应包含以下核心功能：
- 新增联系人（姓名、电话、邮箱等信息）
- 查看所有联系人
- 按姓名查询联系人
- 修改联系人信息
- 删除联系人
- 递归遍历 / 查询（核心亮点）

## 二、技术选型：为什么用顺序表和递归？

- **顺序表**：联系人数据是线性结构，顺序表（数组）支持随机访问，适合存储和快速查找联系人。
- **递归**：递归的本质是 “自身调用自身”，适合实现按条件深度遍历（比如模糊查询时递归查找所有匹配项），代码更简洁。

## 三、数据结构设计

### 1. 联系人信息结构体

首先定义单个联系人的信息结构，包含姓名、性别、年龄、电话、地址：
```C
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#define NAME_MAX 20
#define BANDER_MAX 10
#define PH_MAX 20
#define ADDR_MAX 20

//创建结构体类型
typedef struct personInfo
{
	char name[NAME_MAX];
	char bander[BANDER_MAX];
	int age;
	char ph[PH_MAX];
	char addr[ADDR_MAX];
}peoInfo;//修改类型名称，方便简写代码
```
### 2. 顺序表存储通讯录

用顺序表存储所有联系人，顺序表的元素类型为`Contact`：
```C
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#include"Contact.h"//通讯录头文件

//可以方便修改
typedef peoInfo SLDataType;
//定义动态顺序表的结构
typedef struct SeqList
{
	SLDataType* arr;
	int size;//有效数据个数
	int capecity;//空间大小
}SL;
```
## 四、核心功能实现

### 1. 初始化与扩容

首先实现通讯录的初始化和动态扩容功能：
```C
//通讯录初始化
void ContactAdd(Contact* con)
{
	//获取用户输入的内容：姓名+性别+年龄+电话+地址
	peoInfo info;
	printf("请输入要添加的联系人姓名：\n");
	scanf("%s", info.name);

	printf("请输入要添加的联系人性别：\n");
	scanf("%s", info.bender);

	printf("请输入要添加的联系人年龄：\n");
	scanf("%d", &info.age);

	printf("请输入要添加的联系人电话：\n");
	scanf("%s", info.info);

	printf("请输入要添加的联系人地址：\n");
	scanf("%s", info.addr);

	//往通讯录种添加联系人数据
	SLPushFort(con, info);
}
//判断内存够不够
void SLCheckCapacity(SL* ps)
{
	if (ps->capecity == ps->size)
	{
		//第一种情况，都为0
		//用三目运算符
		int NewCapecity = ps->capecity == 0 ? 4 : ps->capecity * 2;

		//第二种情况，空间不够
		//开辟新空间，tmp来接受
		SLDataType* tmp = (SLDataType*)realloc(ps->arr, NewCapecity * sizeof(SLDataType));
		if (tmp == NULL)
		{
			perror("realloc");
			exit(1);
		}
		//空间申请成功
		ps->arr = tmp;
		ps->capecity = NewCapecity;
	}
}
```
### 2. 查找与删除联系人

想要删除功能，需要基于顺序表的特性实现（删除时需移动元素），并且需要查找到对应联系人，这就需要实现查找联系人的方法：
### 查找联系人姓名
- 需要用循环遍历顺序表
- 找到对应的名字，找到返回i，没找到返回0
```C
//通讯录查找姓名
int ContactFindName(Contact* con, char name[])
{
	//遍历结构体
	for (int i = 0; i < con->size; i++)
	{
		//字符串比较可以strcmp
		if (0 == strcmp(con->arr[i].name, name))
		{
			return i;
		}
	}
	return -1;
}
```
### 删除联系人
- 输入一个名字，利用上面的查找联系人的返回值来找联系人
- 找到了就删除，没找到就打印没找到
```C
//通讯录删除数据
void ContactDel(Contact* con)
{
	char name[NAME_MAX] = {0}; // 初始化为全零，确保有零终止符
	printf("请输入要删除的数据\n");
	scanf("%19s", name); // 限制输入长度，防止溢出

	int find = ContactFindName(con, name);
	if (find < 0)
	{
		printf("要删除的联系人数据不存在!\n");
		return;
	}
	//要删除的联系人数据存在--->知道了要删除联系人数据对应的下标
	SLPop(con, find);
	printf("删除成功\n");
}
```

## 3.修改与查找联系人
```C
//通讯录的修改
void ContactModify(Contact* con)
{
	//要修改的联系人数据存在
	char name[NAME_MAX];
	printf("要修改的用户姓名\n");
	scanf("%s", name);

	int find = ContactFindName(con, name);
	if (find < 0)
	{
		printf("要删除的联系人数据不存在!\n");
		return;
	}
	//直接修改
	printf("请输入要修改的姓名：\n");
	scanf("%s", con->arr[find].name);

	printf("请输入要修改的性别：\n");
	scanf("%s", con->arr[find].bender);

	printf("请输入要修改的年龄：\n");
	scanf("%d", &con->arr[find].age);

	printf("请输入要修改的电话：\n");
	scanf("%s", con->arr[find].info);

	printf("请输入要修改的住址：\n");
	scanf("%s", con->arr[find].addr);

	printf("修改成功\n");
}

//通讯录查找
int ContactFind(Contact* con)
{
	//姓名 性别 年龄 电话 地址
	char name[NAME_MAX];
	printf("请输入要查找的联系人姓名\n");
	scanf("%s", name);

	int find = ContactFindName(con, name);
	if (find < 0)
	{
		printf("要查找的联系人不存在\n");
		return;
	}
	printf("姓名  性别  年龄  电话  地址\n");
	printf("%3s %3s %3d %3s %3s\n", \
		con->arr[find].name,
		con->arr[find].bender,
		con->arr[find].age,
		con->arr[find].info,
		con->arr[find].addr);
}
```
## 五、主程序与菜单

最后实现主函数和交互菜单，串联所有功能：
```C
void menu()
{
	printf("***********通讯录***********\n");
	printf("**** 1. add     2. Del ****\n");
	printf("**** 3. Modify  4. Find****\n");
	printf("**** 5. Show    0.Exit ****\n");
	printf("***************************\n");

}
int main()
{
	Contact con;
	ContactInit(&con);

	int op = 0;
	do
	{
		menu();
		printf("请选择您的操作\n");
		scanf("%d", &op);
		switch (op)
		{
		case 1:
			ContactAdd(&con);
			break;
		case 2:
			ContactDel(&con);
			break;
		case 3:
			ContactModify(&con);
			break;
		case 4:
			ContactFind(&con);
			break;
		case 5:
			ContactPrint(&con);
			break;
		case 0:
			printf("退出通讯录\n");
			break;
		default:
			printf("输入错误\n");
			break;
		}

	} while (op != 0);

	ContactDestroy(&con);

	return 0;
}
```
## 六、递归在通讯录中的优势分析

为什么要用递归实现遍历和查询？相比循环，递归有这些特点：

1. **代码简洁**：递归遍历无需手动控制循环变量，直接通过 “自身调用 + 终止条件” 实现，逻辑更清晰。
2. **适合深度搜索场景**：如果未来扩展通讯录为 “分组联系人”（如家庭组、工作组，组内可嵌套子组），递归能轻松实现多层嵌套结构的遍历，而循环实现会非常复杂。
3. **函数式编程思维**：递归是函数式编程的核心思想之一，有助于培养 “通过函数分解问题” 的思维方式。
## 七、总结与扩展

本文用顺序表存储联系人数据，结合递归实现了通讯录的核心功能。关键知识点：

- 顺序表适合存储线性结构数据，支持快速访问和动态扩容。
- 递归通过 “终止条件 + 自身调用” 实现遍历 / 查询，代码简洁且适合嵌套结构。

**扩展方向**：

1. 增加文件存储功能（将联系人保存到本地文件）。
2. 实现分组联系人（用递归遍历嵌套分组）。
3. 优化查询效率（添加哈希表索引，快速定位联系人）。

通过这个案例，我们不仅掌握了通讯录的实现，更理解了 “数据结构 + 算法思想（递归）” 如何协同解决实际问题。