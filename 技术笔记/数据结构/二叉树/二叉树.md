# 深入理解二叉树：从概念到实现的完整指南
二叉树是树形结构的基础，也是数据结构中的核心知识点，它的 “分支特性” 和 “递归遍历” 思想贯穿后续复杂树形结构（如二叉搜索树、红黑树）的学习。本文将延续栈、队列博客的风格，从**核心概念**、**结构定义**、**遍历算法**、**基本操作**到**应用场景**，带你全面掌握二叉树的原理与代码实现。
# 一、树
## 1.树的概念与结构
树是一种非线性的数据结构，由`n(n>=0)`个有限节点组成一个具有层次关系的集合。因为它看起来像一颗倒挂的数，因此叫做树(根朝上，叶朝下)
- 根节点也为特殊节点，根节点没有前驱节点
- 除根节点，其余节点分为`M(M>0)`个互不相交的集合。每颗树的根节点只有一个前驱，可以有`0`个或多个后继。因此，树是递归定义的。
![](图片/QQ20251112-184751.png)
非树形结构：
![](图片/QQ20251112-184936.png)
- 子树是不相交的(如果存在相交就是图)
- 出来根节点外，每个节点有且只有一个父节点
- 一颗N个节点的树有N-1条边
## 2.树的相关用语
>**父结点/双亲结点**：若一个结点含有子结点，则这个结点称为其子结点的父结点；如上图：A是B的父结点
**子结点/孩子结点**：一个结点含有的子树的根结点称为该结点的子结点；如上图：B是A的孩子结点
**结点的度**：一个结点有几个孩子，他的度就是多少；比如A的度为6，F的度为2，K的度为0
**树的度**：一棵树中，最大的结点的度称为树的度；如上图：树的度为6
**叶子结点/终端结点**：度为0的结点称为叶结点；如上图：B、C、H、I等结点为叶结点
**分支结点/非终端结点**：度不为0的结点；如上图：D、E、F、G等结点为分支结点
**兄弟结点**：具有相同父结点的结点互称为兄弟结点（亲兄弟）；如上图：B、C是兄弟结点
**结点的层次**：从根开始定义起，根为第层，根的子结点为第2层，以此类推；
**树的高度或深度**：树中结点的最大层次；如上图：树的高度为4
**结点的祖先**：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先
**路径**：一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列；比如A到Q的路径为：A-E-J-Q；H到Q的路径H-D-A-E-J-Q
**子孙**：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙
**森林**：由`m(m>o)`棵互不相交的树的集合称为森林;
## 3.树的表示
树的表示有许多种方法，这里就用最常用的**孩子兄弟表示法**
```C
struct TreeNode
{
	struct Node* chile;   //左边开始的第一个孩子节点
	struct NOde* brother; //指向其右边的下一个兄弟节点
	int data;             //节点中的数据域
};
```
![](图片/QQ20251112-190218.png)![](图片/QQ20251112-190229.png)
![](图片/bit-2025-11-12-19-04-31.png)
## 4.树形结构实际运用场景
>文件系统：利用树形结构来组织和管理文件和文件夹
>操作系统：如Windows和Linux中的系统资源管理
# 二、二叉树
## 1.概念与结构
再树形结构中，我们最常用的就是二叉树
- 二叉树是节点的一个有限集合
- 集合由左子树和右子树组成

生活中最典型的二叉树例子是**家族族谱的父子关系**：
- 一个父亲最多有两个孩子（左孩子、右孩子）
- 每个孩子只能有一个父亲（父节点）
- 没有孩子的节点是 “叶子节点”（如同家族中的晚辈）
![](图片/QQ20251112-194642.png)
### (1)二叉树的定义
二叉树是 n（n≥0）个节点的有限集合，满足：
1. 空树（n=0）
2. 由一个根节点和两棵互不相交的、分别称为左子树和右子树的二叉树组成
简单说：**每个节点最多有两个子节点，且左右子树有明确顺序（左≠右）**
>注意：对于任意的二叉树都是由以下几种情况复合而成的
![](图片/QQ20251112-194702.png)
### (2)二叉树的关键术语
- **根节点（Root）**：二叉树的起始节点（无父节点）
- **左孩子（Left Child）**：节点的左分支子节点
- **右孩子（Right Child）**：节点的右分支子节点
- **父节点（Parent）**：拥有子节点的节点
- **叶子节点（Leaf）**：无左、右孩子的节点
- **子树（Subtree）**：以某节点为根的局部二叉树（左子树 / 右子树）
- **深度（Depth）**：根节点到该节点的路径长度（根节点深度为 1）
- **高度（Height）**：该节点到最远叶子节点的路径长度（叶子节点高度为 1）
### (3)二叉树的核心特性
1. 第 i 层最多有 2^(i-1) 个节点（i≥1）
2. 深度为 k 的二叉树最多有 2^k - 1 个节点（满二叉树）
3. 任意二叉树中，叶子节点数 = 度为 2 的节点数 + 1（度：节点的子节点个数）
## 2.特殊的二叉树
### (1)满二叉树
一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，**如果一个二又树的层数为k，且结点总数是`2^k-1`，则它就是满二叉树**
![](图片/QQ20251112-194713.png)
### (2)完美二叉树
**完美二叉树由满二叉树而引出来**，是一个效率很高的数据结构。深度为`K`的完全二叉树有`n`个节点。
![](图片/QQ20251112-194722.png)
要注意：**满二叉树是一种特殊的完全二叉树**

>二叉树性质
根据满二叉树的特点可知：
1）若规定根结点的层数为1，则一棵非空二叉树的第i层上最多有2^(n-1)个结点
2）若规定根结点的层数为1，则深度为h的二叉树的最大结点数是(2^h - 1)
3）若规定根结点的层数为1，具有n个结点的满二叉树的深度`h=log(n+1)（log以2为底，n+1为对数)`
## 3.二叉树存储结构
二叉树一般可以使用两种存储结构：顺序结构、链式结构
### (1)顺序结构
**顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费，完全二叉树更适合使用顺序结构存储。**
![](图片/QQ20251113-095411.png)![](图片/QQ20251113-095434.png)

### (2)链式结构
二叉树也可以用链表。通常由**数据域和左右指针域**，左右指针域表示**左孩子和右孩子所在的链节点的存储地址**。链式结构又分为二叉链和三叉链，大部分都是二叉链。
![](图片/QQ20251113-100229.png)
![](图片/QQ20251113-100238.png)
## 4.二叉树的性质
>1. 若规定根节点的层数为1，则一棵非空二叉树的**第i层上最多有2^(i-1)个节点**
>2. 若规定根节点的层数为1，则**深度h的二叉树的最大节点数是2^h -1
>3. 堆任何一颗二叉树，**如果度为0其叶节点个数为n0，度为2的分支节点个数为n2，则有n0 = n2 + 1**；
>4. 若规定根节点的层数为1，具有**n个节点的满二叉树的深度**，h=log(n+1)。(ps：log(n + 1)是log一2为底，n+1为对数)
>5. 对于具有n个节点的完全二叉树，如果按照从上至下从左至右的数组顺序堆所有节点从0开始编号，则对于编号为i的节点有：
>	- 若`i>0`，`i`位置节点的双亲序号：`(i-1)/2`;`i=0`，`i`为根节点编号，无双亲节点
>	- 若`2i+1<n`，左孩子序号：`2i+1`
>	- 若`2i+2<n`，右孩子序号：`2i+2`
# 三、实现顺序结构二叉树
一般是由堆来实现顺序表和数组来存储数据，堆是一种特殊的二叉树，具有二叉树的特性同时，还具备其他的特性。
## 1.堆的概念与结构
堆分为大堆和小堆
1. 共同的特性
	- 完全二叉树
	- 有任何一个根(父亲)
2. 不同的特性
	- 大堆时根最大
	- 小堆时根最小
![](图片/QQ20251113-101136.png)
![](图片/QQ20251113-101147.png)
>堆具有以下性质
>- 堆中某个节点的值总是不大于/不小于其父节点的值
>- 堆总是一颗完全二叉树
>- 堆不一定为顺序结构

>二叉树的性质
>- 对于具有`n`个节点的完全二叉树，从上至下、从左至右按照数组堆所有节点从0开始编号，则对于序号为`i`的节点有：
>1. 若`i>0`，`i`位置节点的双亲序号：`(i-1)/2`;`i=0`，`i`为根节点编号，无双亲节点
>2. 若`2i+1<n`，左孩子序号：`2i+1`
>3. 若`2i+2<n`，右孩子序号：`2i+2`
## 2.堆的实现（数组实现）
堆具有二叉树的性质，可以实现比冒泡排序`O(N^2)`更好的排序，也就是**堆排序，同时可以找最大或最小，时间复杂度为`O(N+logN)`**。
### (1)堆的定义
```C
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#include<stdbool.h>

typedef int HPDataType;

typedef struct Head
{
	HPDataType* a; //物理上，堆是个数组
	int size;      //堆的大小
	int capacity;  //堆可插入的数据
}HP;
```
### (2)堆的创建
```C
//堆的初始化
void HPInit(HP* php);
```

```C
//堆的初始化
void HPInit(HP* php)
{
	assert(php);
	php->a = NULL;
	php->size = php->capacity = 0;
}
```
### (3)堆元素的交换
```C
//两个数组元素交换位置
void swap(HPDataType* x, HPDataType* y);
```

```C
//用指针来交换地址
void swap(HPDataType* x, HPDataType* y)
{
	HPDataType tmp = *x;
	*x = *y;
	*y = tmp;
}
```
### (4)堆的尾插和向上排序
```C
//尾插数据 + 向上排序
void HPPush(HP* php, HPDataType x);

//向上排序
void AdjustUP(HPDataType* a, int child);
```

```C
//向上排序
void AdjustUP(HPDataType* a, int child)
{
	//父亲节点
	int ancestor = (child - 1) / 2;

	//条件：当孩子到达首元素停止循环
	while (child > 0)
	{
		//孩子比父亲小，则向上排序(小堆)
		if (a[child] < a[ancestor])
		{
			//条件满足，交换位置
			swap(&(a[ancestor]), &(a[child]));
			//新的一轮
			child = ancestor;
			ancestor = (child - 1) / 2;
		}
		else//不满足条件，跳出while循环
		{
			break;
		}
	}
}

//尾插数据
void HPPush(HP* php, HPDataType x)
{
	assert(php);

	//判断空间是否足够
	if (php->capacity == php->size)
	{
		//三目运算符：
		//1. 当无空间时，申请4个字节
		//2. 当有空间时，将空间乘2倍
		int newcapacity = php->capacity == 0 ? 4 : php->capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(php->a, newcapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("realloc fail!!!");
			return;
		}
		//赋值新变量
		php->a = tmp;
		php->capacity = newcapacity;
	}
	//尾插数据，长度+1
	php->a[php->size] = x;
	php->size++;

	//尾插完，排序(大堆/小堆)
	AdjustUP(php->a, php->size - 1);
}
```
### (5)堆的头删和向下排序
```C
//删除头元素(先首位交换，再尾删，后向下排序)
void HPPop(HP* php);

//向下排序
void AdjustDown(HPDataType* a, int n, int zero);
```

```C
//向下排序
void AdjustDown(HPDataType* a, int n, int ancestor)
{
	//保持紧密的父子关系
	int child = ancestor * 2 + 1;

	//当孩子比总节点大时，停止循环
	while (child < n)
	{
		//两兄弟之间比较(谁大谁小)
		if (child + 1 < n && a[child + 1] < a[child])
		{
			child++;
		}

		//兄弟与父亲比较，兄弟小则交换
		if (a[child] < a[ancestor])
		{
			swap(&(a[child]), &(a[ancestor]));
			ancestor = child;
			child = ancestor * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

//尾删(先首尾交换，避免打乱堆)
void HPPop(HP* php)
{
	assert(php);
	assert(php->size > 0);

	//首尾交换
	swap(&php->a[0], &php->a[php->size - 1]);
	//总大小-1
	php->size--;

	//向下排序
	AdjustDown(php->a, php->size, 0);
}
```
### (6)堆的首元素查询
```C
//取头元素
HPDataType HPTom(HP* php);
```

```C
//首元素查询
HPDataType HPTom(HP* php)
{
	assert(php);
	assert(php->size > 0);

	return php->a[0];
}
```
### (7)堆的判空
```C
//判空
bool HPEmpty(HP* php);
```

```C
//判空
bool HPEmpty(HP* php)
{
	assert(php);

	return php->size == 0;
}
```
### (8)堆的删除
```C
//堆的删除
void HPDestory(HP* php);
```

```C
//堆的删除
void HPDestory(HP* php)
{
	assert(php);

	free(php->a);
	php->a = NULL;

	php = NULL;
	php->size = php->capacity = 0;
}
```
实现堆的基础后，就可以完成强大的堆排序了(有序排序)

## 3.向上调整法
>堆的插入

将新数据插入到数组为的尾上，再进行向上调整算法，直到满足堆
- 先将元素插入到堆的末尾
- 插入之后，如果堆的性质遭到破坏，将新插入节点顺着其双亲往上调整到合适位置
![](图片/QQ20251116-134005.png)
```C
//尾插数据 + 向上排序
void HPPush(HP* php, HPDataType x);

//向上排序
void AdjustUP(HPDataType* a, int child);
```

```C
//向上排序
void AdjustUP(HPDataType* a, int child)
{
	//父亲节点
	int ancestor = (child - 1) / 2;

	//条件：当孩子到达首元素停止循环
	while (child > 0)
	{
		//孩子比父亲小，则向上排序(小堆)
		if (a[child] < a[ancestor])
		{
			//条件满足，交换位置
			swap(&(a[ancestor]), &(a[child]));
			//新的一轮
			child = ancestor;
			ancestor = (child - 1) / 2;
		}
		else//不满足条件，跳出while循环
		{
			break;
		}
	}
}

//尾插数据
void HPPush(HP* php, HPDataType x)
{
	assert(php);

	//判断空间是否足够
	if (php->capacity == php->size)
	{
		//三目运算符：
		//1. 当无空间时，申请4个字节
		//2. 当有空间时，将空间乘2倍
		int newcapacity = php->capacity == 0 ? 4 : php->capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(php->a, newcapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("realloc fail!!!");
			return;
		}
		//赋值新变量
		php->a = tmp;
		php->capacity = newcapacity;
	}
	//尾插数据，长度+1
	php->a[php->size] = x;
	php->size++;

	//尾插完，排序(大堆/小堆)
	AdjustUP(php->a, php->size - 1);
}
```
>计算向上调整算法建堆的时间复杂度

因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明（时间复杂度本来看的就是近似值，多几个结点不影响最终结果）
![](图片/QQ20251116-134659.png)
![](图片/QQ20251116-134825.png)
由此可得：
- 向上调整算法建堆时间复杂度为：`O(n * log n)`
## 4.向下调整法
>堆删除

删除堆是删除堆顶的数据，将**堆顶的数据根最后一个数据一换，然后删除数组最后一个数据，再进行向下调整算法**
![](图片/QQ20251116-135137.png)
向下调整算法有一个前提：左右子树必须是一个堆，才能调整
- 将堆顶元素与堆中最后一个元素进行交换
- 删除堆中最后一个元素
- 将堆顶元素向下调整到满足堆特性为止
![](图片/QQ20251116-135201.png)
```C
//删除头元素(先首位交换，再尾删，后向下排序)
void HPPop(HP* php);

//向下排序
void AdjustDown(HPDataType* a, int n, int zero);
```

```C
//向下排序
void AdjustDown(HPDataType* a, int n, int ancestor)
{
	//保持紧密的父子关系
	int child = ancestor * 2 + 1;

	//当孩子比总节点大时，停止循环
	while (child < n)
	{
		//两兄弟之间比较(谁大谁小)
		if (child + 1 < n && a[child + 1] < a[child])
		{
			child++;
		}

		//兄弟与父亲比较，兄弟小则交换
		if (a[child] < a[ancestor])
		{
			swap(&(a[child]), &(a[ancestor]));
			ancestor = child;
			child = ancestor * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

//尾删(先首尾交换，避免打乱堆)
void HPPop(HP* php)
{
	assert(php);
	assert(php->size > 0);

	//首尾交换
	swap(&php->a[0], &php->a[php->size - 1]);
	//总大小-1
	php->size--;

	//向下排序
	AdjustDown(php->a, php->size, 0);
}
```
![](图片/QQ20251116-135655.png)
由此可得：向下调整算法建堆时间复杂度为：`O(n)`
## 5.堆的应用
### (1)堆排序
>堆排序即利用堆的思想来进行排序，总共分为两个步骤：
>1. 建堆
>	- 升序：建大堆
>	- 降序：建小堆
>2. 利用堆删除思想来进行排序

在test文件中这样写：
```C
#define _CRT_SECURE_NO_WARNINGS
#include"heap.h"

void HPTest01()
{
	int a[] = { 4,2,8,1,5,6,9,7,3,2,23,55,232,66,222,33,7,1,66,3333,999 };
	HP hp;
	HPInit(&hp);
	for (size_t i = 0; i < sizeof(a) / sizeof(int); i++)
	{
		HPPush(&hp, a[i]);
	}
	
	int i = 0;
	while (!HPEmpty(&hp))
	{
		printf("%d ", HPTop(&hp));
		//a[i++] = HPTop(&hp);
		HPPop(&hp);
	}
	printf("\n");
	
	
	HPDestory(&hp);
	}

int main()
{
	HPTest01();
	return 0;
}
```

```C
// 堆排序    O(N*logN)
// 冒泡排序  O(N^2)
void HeapSort(int* a, int n)
{
	// 降序，建小堆
	// 升序，建大堆
	/*for (int i = 1; i < n; i++)
	{
		AdjustUp(a, i);
	}*/
	/*for (int i = 1; i < n; i++)
	{
		AdjustUp(a, i);
	}*/
	for (int i = (n-1-1)/2; i >= 0; i--)
	{
		AdjustDown(a, n, i);
	}
	int end = n - 1;
	while (end > 0)
	{
		Swap(&a[0], &a[end]);
		AdjustDown(a, end, 0);
		--end;
	}
}

void TestHeap2()
{
	int a[] = { 4,2,8,1,5,6,9,7,2,7,9};
	HeapSort(a, sizeof(a) / sizeof(int));
}

int main()
{
	TestHeap2();
	return 0;
}
```
### (2)TOP-K问题
TOP-K问题：即求数据结合中前K和最大的元素/最小的元素。
1. 用数据集合中前KIK个元素来建堆
	- 前k个最大的元素，建小堆
	- 前k个最小的元素，建大堆
2. 用剩余的n-k个元素依次与堆顶元素来比较，不满足则替换堆顶元素
	- 将剩余n-k个元素依次与堆顶元素比完之后，堆中剩余的k个元素就是所求的前k和最小/最大的元素
```C
//TOP-K问题
void CreateNDate();
void topk();
```

```C
//TOP-K问题
void CreateNDate()
{
	// 造数据
	 int n = 100000;
	 srand(time(0));
	 const char* file = "data.txt";
	 FILE * fin = fopen(file, "w");
	 if (fin == NULL)
		 {
			perror("fopen error");
			return;
		 }
	
	for (int i = 0; i < n; ++i)
	{
		int x = (rand() + i) % 1000000;
		fprintf(fin, "%d\n", x);
	}
	
	fclose(fin);
	
}

 void topk()
 {
	printf("请输⼊k：>");
	int k = 0;
	scanf("%d", &k);
	
	const char* file = "data.txt";
	FILE * fout = fopen(file, "r");
	if (fout == NULL)
	{
		perror("fopen error");
		return;
	}
	
	int val = 0;
	int* minheap = (int*)malloc(sizeof(int) * k);
	if (minheap == NULL)
	{
		perror("malloc error");
		return;
	}
	
	for (int i = 0; i < k; i++)
	{
		fscanf(fout, "%d", &minheap[i]);
	}
	
	// 建k个数据的小堆
	for (int i = (k - 1 - 1) / 2; i >= 0; i--)
	{
		AdjustDown(minheap, k, i);
	}
	
	int x = 0;
	while (fscanf(fout, "%d", &x) != EOF)
	{
	// 读取剩余数据，比堆顶的值大，就替换他进堆
		if (x > minheap[0])
		{
			minheap[0] = x;
			AdjustDown(minheap, k, 0);
		}
	}
	
	for (int i = 0; i < k; i++)
	{
		printf("%d ", minheap[i]);
	}
	
	fclose(fout);
}
```

# 四、实现链式二叉树
## 1.链式二叉树的定义
用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。通常的方法是**链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址**，其结构如下：
```C
#pragma once
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>
#include<stdbool.h>

typedef int BTDataType;

//二叉链
typedef struct BinaryTreeNode
{
	BTDataType Data;              //数据域
	struct BInaryTreeNode* left;  //指向当前左孩子节点
	struct BInaryTreeNode* right; //指向当前右孩子节点
}BTNode;
```
## 2.链式二叉树的创建
```C
//返回节点的地址，方便创建二叉树的节点
BTNode* BuyNode(int x);
```

```C
//返回节点的地址，方便创建二叉树的节点
BTNode* BuyNode(int x)
{
	//给节点申请空间
	BTNode* newnode = (BTNode*)malloc(sizeof(BTNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode->Data = x;
	newnode->left = NULL;
	newnode->right = NULL;

	//返回节点地址
	return newnode;
}
```

## 3.链式二叉树的形成
```C
//返回第一个节点的地址，创建其他子树的节点
BTNode* CreatBinaryTree();
```

```C
//返回第一个节点的地址，创建其他子树的节点
BTNode* CreatBinaryTree()
{
	//创建每个节点、并赋值
	BTNode* node1 = BuyNode(1);
	BTNode* node2 = BuyNode(2);
	BTNode* node3 = BuyNode(3);
	BTNode* node4 = BuyNode(4);
	BTNode* node5 = BuyNode(5);
	BTNode* node6 = BuyNode(6);
	BTNode* node7 = BuyNode(7);
	BTNode* node8 = BuyNode(8);

	//形成一棵树
	node1->left = node2;
	node1->right = node5;
	node2->left = node3;
	node2->right = node4;
	node5->left = node6;
	node5->right = node7;
	node6->left = node8;

	//返回首节点为
	return node1;
}
```

## 4.前中后序遍历
二叉树的操作离不开树的遍历
![](图片/QQ20251114-211648.png)
### (1)遍历规则
按照规则，二叉树的遍历分为：前序/中序/后序的递归结构遍历：
1. 前序遍历：访问根节点的操作发生在遍历其左右子树之前
>访问顺序为：根节点、左子树、右子树

2. 中序遍历：访问根节点的操作发生在遍历其左右子树之间
>访问顺序为：左子树、根节点、右子树

3. 后序遍历：访问根节点的操作发生在遍历其左右子树之后
>访问顺序为：左子树、右子树、根节点
### (2)链式二叉树的前序
```C
//前序遍历   根节点、左子树、右子树
void prevorder(BTNode* root);
```

```C
//前序遍历   根节点、左子树、右子树
void prevorder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	printf("%d ", root->Data);
	prevorder(root->left);
	prevorder(root->right);
}
```
### (3)链式二叉树的中序
```C
//中序遍历   左子树、根节点、右子树
void inorder(BTNode* root);
```

```C
//中序遍历   左子树、根节点、右子树
void inorder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	prevorder(root->left);
	printf("%d ", root->Data);
	prevorder(root->right);
}
```
### (4)链式二叉树的后序
```C
//后序遍历   左子树、右子树、根节点
void tailorder(BTNode* root);
```

```C
//后序遍历   左子树、右子树、根节点
void tailorder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}

	prevorder(root->left);
	prevorder(root->right);
	printf("%d ", root->Data);
}
```
图解遍历：
>以前序遍历为例：

![](图片/QQ20251114-212309.png)

函数递归栈帧图：
![](图片/QQ20251114-212353.png)
## 5.链式二叉树节点个数
**需用递归遍历二叉树**
```C
//查找二叉树节点
int TreeSize(BTNode* root);
```

```C
//查找二叉树节点
int TreeSize(BTNode* root)
{
	return root == NULL ? 0 : TreeSize(root->left) + TreeSize(root->right) + 1;
}
```
## 6.链式二叉树的叶子个数
**先判断树是否为空，然后需用条件语句判断两边是否是是空，然后用递归循环遍历**
```C
//查找二叉树叶子节点
int TreeLeafSize(BTNode* root);
```

```C
//查找二叉树叶子节点
int TreeLeafSize(BTNode* root)
{
	//树为空
	if (root == NULL)
		return 0;
	
	//叶子节点，返回1
	if (root->left == NULL && root->right == NULL)
		return 1;

	//找不到，遍历二叉树
	return TreeLeafSize(root->left) + TreeLeafSize(root->right);
}
```
## 7.链式二叉树高度
**先判断树是否为空，然后左子树往左递归，右子树往右递归，然后比较大小**
```C
//查找二叉树高度
int TreeHeight(BTNode* root);
```

```C
//查找二叉树高度
int TreeHeight(BTNode* root)
{
	//树为空，高度为1
	if (root == NULL)
		return 1;

	//递归遍历，记录树两边的高度
	int leftcount = TreeHeight(root->left);
	int rightcount = TreeHeight(root->right);
	
	//比较两边高度(三目运算符)
	return 1 + (leftcount > rightcount ? leftcount : rightcount);
}
```
## 8.链式二叉树查找第K层节点个数
**先判断树是否为空，再设一个K变量，遍历一次k--，直到k不满足条件退出循环为止**
```C
//查找第K层的节点个数
int TreeLeveKSize(BTNode* root, int k);
```

```C
//查找第K层的节点个数
int TreeLeveKSize(BTNode* root, int k)
{
	//树为空
	if (root == NULL)
		return 0;

	if (k == 1)
		return 1;

	//子问题
	return TreeLeveKSize(root->left, k - 1) + TreeLeveKSize(root->right, k - 1);
}
```
## 9.链式二叉树查找值为x的节点
**先判断树是否为空，再遍历二叉树，用条件语句判断节点是否为x，为x则返回当前节点**
```C
//二叉树查找值为x的节点
BTNode* TreeFind(BTNode* root, BTDataType x);
```

```C
//二叉树查找值为x的节点
BTNode* TreeFind(BTNode* root, BTDataType x)
{
	//树为空/子树左孩子为空
	if (root == NULL)
		return NULL;

	//找到节点
	if (root->Data == x)
		return root;

	//没找到，往左子树找
	BTNode* ret1 = TreeFind(root->left, x);
	if (ret1)
		return ret1;

	//左子树没找到，往右子树找
	BTNode* ret2 = TreeFind(root->right, x);
	if (ret2)
		return ret2;

	//都没找到返回NULL
	return NULL;
}
```
## 10.链式二叉树的销毁
**先判断树是否为空，再用递归遍历二叉树，利用后序销毁节点，防止先把节点销毁找不到子树**
```C
//二叉树的销毁
void TreeDestory(BTNode* root);
```

```C
//二叉树的销毁
void TreeDestory(BTNode* root)
{
	if (root == NULL)
		return;

	//递归销毁
	TreeDestory(root->left);
	TreeDestory(root->right);
	free(root);
}
```
## 11.链式二叉树的广度遍历
**需要用到队列(先进先出)，把第一个节点放入队列，把第一个节点拿出来，然后再把子树的两个节点放入队列里。把第二个节点拿出来，然后把子树的两个几点放入队列里，用递归循环往复即可(当在队列拿出节点时，需要把第一个节点存在另一颗树中)**

**需要在文件中，找到之前写的队列，复制粘贴到二叉树的文件中，然后再添加队列的头文件和源文件**
```C
#include"Queue.h"

typedef struct BinaryTreeNode* QDataType;
```
**注意：**
1. 包含头文件时，需要在`Queue.h`中，将`typedef int QDataType`修改成`typedef struct BinaryTreeNode* QDataType`

```C
//层序遍历(广度优先遍历)
void TreeLevelOrder(BTNode* root);
```

```C
#include"Queue.h"
//层序遍历(广度优先遍历)
void TreeLevelOrder(BTNode* root)
{
	//定义一个队列
	Queue q;
	QueueInit(&q);

	//如果树不等于空，就把树放进去
	if (root)
		QueuePush(&q, root);

	//如果队列不等于空就继续
	//当等于空时，树的节点走完
	while (!QueueEmpty(&q))
	{
		//保存树节点的指针
		BTNode* front = QueueFront(&q);
		QueuePop(&q);//取出来就要拿出来

		printf("%d ", front->Data);

		//然后把两个子树放进去
		if (front->left)
			QueuePush(&q, front->left);

		if (front->right)
			QueuePush(&q, front->right);
	}

	//用完则销毁队列
	QueueDestroy(&q);
}```


